{
    "contents" : "#' Wrapper function of \\code{MatH} class\n#' \n#' This function create a matrix of histogram data, i.e. a \\code{MatH}\n#' object\n#' \n#' @name MatH\n#' @rdname MatH-class\n#' @export\n#' @param x (optional, default= an empty \\code{distributionH} object) a list of\n#' \\code{distributionH} objects\n#' @param nrows (optional, default=1)an integer, the number of rows.\n#' @param ncols (optional, default=1) an integer, the number of columns (aka\n#' variables).\n#' @param rownames (optional, default=NULL) a list of strings containing the\n#' names of the rows.\n#' @param varnames (optional, default=NULL) a list of strings containing the\n#' names of the columns (aka variables).\n#' @param by.row (optional, default=FALSE) a logical value, TRUE the matrix is\n#' row wise filled, FALSE the matrix is filled column wise.\n#' @return A \\code{matH} object\n#' @examples\n#' \n#' #bulding an empty 10 by 4 matrix of histograms\n#' MAT=MatH(nrows=10,ncols=4)\n\nMatH=function(x=list(new('distributionH')), nrows=1, ncols=1,rownames=NULL,varnames=NULL, by.row=FALSE ){\n  MAT=new('MatH', \n          nrows=nrows,\n          ncols=ncols,\n          ListOfDist=x, \n          names.rows=rownames, \n          names.cols=varnames, by.row=by.row)\n  return(MAT)\n}\n\n# overriding of \"[\" operator for MatH object ----\n#' Method [\n#' @name [\n#' @rdname extract-methods\n#' @aliases [,MatH-method\n#' @aliases [-methods\n#' @description This method overrides the \"[\" operator for a  \\code{matH} object.\n#' @param x a \\code{matH} object\n#' @param i  a set of integer values identifying the rows\n#' @param j  a set of integer values identifying the columns\n#' @param ... not useful\n#' @param drop a logical value iherited from the basic method \"[\" but not used (default=TRUE)\n#' @return A \\code{matH} object\n#' @examples\n#' D=BLOOD #the BLOOD dataset\n#' SUB_D=BLOOD[c(1,2,5),c(1,2)]\n#' @exportMethod [\nsetMethod(\"[\",\n          signature(x = \"MatH\"),\n          function (x, i, j, ..., drop = TRUE) \n          {\n            if (missing(i) &&  missing(j)) {\n              i=c(1:nrow(x@M))\n              j=c(1:ncol(x@M))\n            }\n            else{\n              if (missing(i)) i=c(1:nrow(x@M))\n              if (missing(j)) j=c(1:ncol(x@M))\n            }\n            \n            MAT=new(\"MatH\",length(i),length(j))\n            for (r in 1:length(i)){\n              for (c in 1:length(j)){\n                MAT@M[r,c][[1]]=x@M[i[r],j[c]][[1]]\n              }\n            }\n            \n            rownames(MAT@M)=row.names(x@M)[i]\n            colnames(MAT@M)=variable.names(x@M)[j]\n            return(MAT)\n          }\n)\n# methods for getting information from a MatH\n#' Method get.MatH.nrows\n#' @name get.MatH.nrows\n#' @rdname get.MatH.nrows-methods\n#' @exportMethod get.MatH.nrows\nsetGeneric(\"get.MatH.nrows\",function(object) standardGeneric(\"get.MatH.nrows\"))\n#' @rdname get.MatH.nrows-methods\n#' @aliases get.MatH.nrows,MatH-method\n#' @description It returns the number of rows of a \\code{MatH} object\n#' @param object  a \\code{MatH} object\n#' @return An integer, the number of rows.\nsetMethod(f=\"get.MatH.nrows\",signature=c(object=\"MatH\"),\n          function(object){\n            return(nrow(object@M))\n          }\n)\n#' Method get.MatH.ncols\n#' @name get.MatH.ncols\n#' @rdname get.MatH.ncols-methods\n#' @exportMethod get.MatH.ncols\n\nsetGeneric(\"get.MatH.ncols\",function(object) standardGeneric(\"get.MatH.ncols\"))\n#' @rdname get.MatH.ncols-methods\n#' @aliases get.MatH.ncols,MatH-method\n#' @description It returns the number of columns of a \\code{MatH} object\n#' @param object  a \\code{MatH} object\n#' @return An integer, the number of columns.\nsetMethod(f=\"get.MatH.ncols\",signature=c(object=\"MatH\"),\n          function(object){\n            return(ncol(object@M))\n          }\n)\n#' Method get.MatH.rownames\n#' @name get.MatH.rownames\n#' @rdname get.MatH.rownames-methods\n#' @exportMethod get.MatH.rownames\nsetGeneric(\"get.MatH.rownames\",function(object) standardGeneric(\"get.MatH.rownames\"))\n#' @rdname get.MatH.rownames-methods\n#' @aliases get.MatH.rownames,MatH-method\n#' @description It returns the labels of the rows of a \\code{MatH} object\n#' @param object  a \\code{MatH} object\n#' @return A vector of char, the label of the rows.\nsetMethod(f=\"get.MatH.rownames\",signature=c(object=\"MatH\"),\n          function(object){\n            return(rownames(object@M))\n          }\n)\n#' Method get.MatH.varnames\n#' @name get.MatH.varnames\n#' @rdname get.MatH.varnames-methods\n#' @exportMethod get.MatH.varnames\nsetGeneric(\"get.MatH.varnames\",function(object) standardGeneric(\"get.MatH.varnames\"))\n#' @rdname get.MatH.varnames-methods\n#' @aliases get.MatH.varnames,MatH-method\n#' @description It returns the labels of the columns, or the names of the variables, of a \\code{MatH} object\n#' @param object  a \\code{MatH} object\n#' @return A vector of char, the labels of the columns, or the names of the variables.\nsetMethod(f=\"get.MatH.varnames\",signature=c(object=\"MatH\"),\n          function(object){\n            return(colnames(object@M))\n          }\n)\n#' Method get.MatH.main.info\n#' @name get.MatH.main.info\n#' @rdname get.MatH.main.info-methods\n#' @exportMethod get.MatH.varnames\nsetGeneric(\"get.MatH.main.info\",function(object) standardGeneric(\"get.MatH.main.info\"))\n#' @rdname get.MatH.main.info-methods\n#' @aliases get.MatH.main.info,MatH-method\n#' @description It returns the number of rows, of columns the labels of rows and columns of a \\code{MatH} object.\n#' @param object  a \\code{MatH} object\n#' @return A list of char, the labels of the columns, or the names of the variables.\n#' @slot nrows - the number of rows\n#' @slot ncols - the number of columns\n#' @slot rownames - a vector of char, the names of rows\n#' @slot varnames - a vector of char, the names of columns\n#' \nsetMethod(f=\"get.MatH.main.info\",signature=c(object=\"MatH\"),\n          function(object){\n              return(list(nrows=get.MatH.nrows(object), ncols=get.MatH.ncols(object),\n                        rownames=get.MatH.rownames(object),varnames=get.MatH.varnames(object)))\n          }\n)\n#' Method get.MatH.stats\n#' @name get.MatH.stats\n#' @rdname get.MatH.stats-methods\n#' @exportMethod get.MatH.stats\nsetGeneric(\"get.MatH.stats\",function(object,...) standardGeneric(\"get.MatH.stats\"))\n\n#' @rdname get.MatH.stats-methods\n#' @aliases get.MatH.stats,MatH-method\n#' @description It returns statistics for each distribution contained in a \\code{MatH} object.\n#' @param object  a \\code{MatH} object\n#' @param ... a set of other parameters\n#' @param stat (optional) a string containing the required statistic. Default='mean'\\cr\n#' - \\code{stat='mean'} - for computing the mean of each histogram\\cr\n#' - \\code{stat='median'} - for computing the median of each histogram\\cr\n#' - \\code{stat='min'} - for computing the minimum of each histogram\\cr\n#' - \\code{stat='max'} - for computing the maximum of each histogram\\cr\n#' - \\code{stat='std'} - for computing the standard deviatio of each histogram\\cr\n#' - \\code{stat='skewness'} - for computing the skewness of each histogram\\cr\n#' - \\code{stat='kurtosis'} - for computing the kurtosis of each histogram\\cr\n#' - \\code{stat='quantile'} - for computing the quantile ot level \\code{prob} of each histogram\\cr\n#' @param prob (optional)a number between 0 and 1 for computing the value once choosen the \\code{'quantile'} option for \\code{stat}.\n#' @return A list \n#' @slot stat - the chosen statistic\n#' @slot prob - level of probability if stat='quantile'\n#' @slot MAT - a matrix of values\n#' @examples\n#' get.MatH.stats(BLOOD) # the means of the distributions in BLOOD dataset\n#' get.MatH.stats(BLOOD,stat='median') # the medians of the distributions in BLOOD dataset\n#' get.MatH.stats(BLOOD,stat='quantile', prob=0.5) #the same as median\n#' get.MatH.stats(BLOOD,stat='min') # minima of the distributions in BLOOD dataset\n#' get.MatH.stats(BLOOD,stat='quantile', prob=0) #the same as min\n#' get.MatH.stats(BLOOD,stat='max') # maxima of the distributions in BLOOD dataset\n#' get.MatH.stats(BLOOD,stat='quantile', prob=1) #the same as max\n#' get.MatH.stats(BLOOD,stat='std') # standard deviations of the distributions in BLOOD dataset\n#' get.MatH.stats(BLOOD,stat='skewness') #skewness indices of the distributions in BLOOD dataset\n#' get.MatH.stats(BLOOD,stat='kurtosis') #kurtosis indices of the distributions in BLOOD dataset\n#' get.MatH.stats(BLOOD,stat='quantile',prob=0.05) \n#' #the fifth percentiles of distributions in BLOOD dataset\n\nsetMethod(f=\"get.MatH.stats\",signature=c(object=\"MatH\"),\n          function(object, stat='mean', prob=0.5){\n            r=get.MatH.nrows(object)\n            c=get.MatH.ncols(object)\n            MAT=matrix(NA,get.MatH.nrows(object),get.MatH.ncols(object))\n            rownames(MAT)=get.MatH.rownames(object)\n            colnames(MAT)=get.MatH.varnames(object)\n            for (i in 1:r){\n              for (j in 1:c){\n                if (length(object@M[i,j][[1]]@x)>0){\n                  if (stat=='mean'){\n                    MAT[i,j]=object@M[i,j][[1]]@m\n                  }\n                  if (stat=='std'){\n                    MAT[i,j]=object@M[i,j][[1]]@s\n                  }\n                  if (stat=='skewness'){\n                    MAT[i,j]=skewH(object@M[i,j][[1]])\n                  }\n                  if (stat=='kurtosis'){\n                    MAT[i,j]=kurtH(object@M[i,j][[1]])\n                  }\n                  if (stat=='median'){\n                    MAT[i,j]=compQ(object = object@M[i,j][[1]],p=0.5)\n                  }\n                  if (stat=='quantile'){\n                    MAT[i,j]=compQ(object = object@M[i,j][[1]],p=prob)\n                  }\n                  if (stat=='min'){\n                    MAT[i,j]=compQ(object = object@M[i,j][[1]],p=0)\n                  }\n                  if (stat=='max'){\n                    MAT[i,j]=compQ(object = object@M[i,j][[1]],p=1)\n                  }\n                  \n                }\n              }\n            }\n            if (stat=='quantile'){\n              return(list(stat=stat, prob=prob, mat=MAT))\n            } else{\n            return(list(stat=stat, mat=MAT))\n            }\n          }\n)\n\n\n\n\n# methods for collating by row or by column two MatHs ----\n#' Method WH.bind.row\n#' @name WH.bind.row\n#' @rdname WH.bind.row-methods\n#' @exportMethod WH.bind.row\nsetGeneric(\"WH.bind.row\",function(object1,object2) standardGeneric(\"WH.bind.row\"))#\n#' Method WH.bind.col\n#' @name WH.bind.col\n#' @rdname WH.bind.col-methods\n#' @exportMethod WH.bind.col\nsetGeneric(\"WH.bind.col\",function(object1,object2) standardGeneric(\"WH.bind.col\"))#\n#' Method WH.bind\n#' @name WH.bind\n#' @rdname WH.bind-methods\n#' @exportMethod WH.bind\nsetGeneric(\"WH.bind\",function(object1,object2,byrow) standardGeneric(\"WH.bind\"))#\n#' @rdname WH.bind.row-methods\n#' @aliases WH.bind.row,MatH-method\n#' @description It attaches two \\code{MatH} objects with the same columns by row.\n#' @param object1  a \\code{MatH} object\n#' @param object2  a \\code{MatH} object\n#' @return a \\code{MatH} object,  \n#' @examples\n#' M1<-BLOOD[1:3,]\n#' M2<-BLOOD[5:8,]\n#' MAT<-WH.bind.row(M1,M2)\n\nsetMethod(f=\"WH.bind.row\",signature=c(object1=\"MatH\",object2=\"MatH\"),\n          function(object1,object2){\n            ncol1=ncol(object1@M)\n            ncol2=ncol(object2@M)\n            nrow1=nrow(object1@M)\n            nrow2=nrow(object2@M)\n            if (ncol1!=ncol2){stop(\"The two matrix must have the same number of columns\")}\n            NewMat=new(\"MatH\", nrows=nrow1+nrow2,ncols=ncol1)\n            NewMat@M=rbind(object1@M,object2@M)\n            return(NewMat)\n          }\n          )\n#' @rdname WH.bind.col-methods\n#' @aliases WH.bind.col,MatH-method\n#' @description It attaches two \\code{MatH} objects with the same rows by colums.\n#' @param object1  a \\code{MatH} object\n#' @param object2  a \\code{MatH} object\n#' @return a \\code{MatH} object,  \n#' @examples\n#' M1<-BLOOD[1:10,1]\n#' M2<-BLOOD[1:10,3]\n#' MAT<-WH.bind.col(M1,M2)\nsetMethod(f=\"WH.bind.col\",signature=c(object1=\"MatH\",object2=\"MatH\"),\n          function(object1,object2){\n            ncol1=ncol(object1@M)\n            ncol2=ncol(object2@M)\n            nrow1=nrow(object1@M)\n            nrow2=nrow(object2@M)\n            if (nrow1!=nrow2){stop(\"The two matrix must have the same number of rows\")}\n            NewMat=new(\"MatH\", nrows=nrow1,ncols=ncol1+ncol2)\n            NewMat@M=cbind(object1@M,object2@M)\n            return(NewMat)\n          }\n)\n#' @rdname WH.bind-methods\n#' @aliases WH.bind,MatH-method\n#' @description It attaches two \\code{MatH} objects with the same columns by row, or the same rows by colum.\n#' @param object1  a \\code{MatH} object\n#' @param object2  a \\code{MatH} object\n#' @param byrow  a logical value (default=TRUE) attaches the objects by row\n#' @return a \\code{MatH} object,  \n#' @examples\n#' # binding by row \n#' M1<-BLOOD[1:10,1]\n#' M2<-BLOOD[1:10,3]\n#' MAT<-WH.bind(M1,M2, byrow=TRUE)\n#' # binding by col\n#' M1<-BLOOD[1:10,1]\n#' M2<-BLOOD[1:10,3]\n#' MAT<-WH.bind(M1,M2, byrow=FALSE)\n#' @seealso \\code{\\link{WH.bind.row}} for binding by row, \\code{\\link{WH.bind.col}} for binding by column \nsetMethod(f=\"WH.bind\",signature=c(object1=\"MatH\",object2=\"MatH\"),\n          function(object1,object2, byrow=TRUE){\n            ncol1=ncol(object1@M)\n            ncol2=ncol(object2@M)\n            nrow1=nrow(object1@M)\n            nrow2=nrow(object2@M)\n            if (byrow==TRUE){\n              NewMat=WH.bind.row(object1,object2)\n            }\n            else{\n              NewMat=WH.bind.col(object1,object2)\n            }\n            return(NewMat)\n          }\n)\n\n# methods for MatH based on the L2 Wasserstein distance between distributions ----\n#' Method WH.mat.sum\n#' @name WH.mat.sum\n#' @rdname WH.mat.sum-methods\n#' @exportMethod WH.mat.sum\nsetGeneric(\"WH.mat.sum\",function(object1,object2) standardGeneric(\"WH.mat.sum\"))#ok matrix sum\n#' Method WH.mat.prod\n#' @name WH.mat.prod\n#' @rdname WH.mat.prod-methods\n#' @exportMethod WH.mat.prod\nsetGeneric(\"WH.mat.prod\",function(object1,object2,...) standardGeneric(\"WH.mat.prod\"))#ok matrix product\n#' @rdname WH.mat.sum-methods\n#' @aliases WH.mat.sum,MatH-method\n#' @description It sums two \\code{MatH} objects, i.e. two matrices of distributions, \n#' by summing the quantile functions of histograms. This sum is consistent with \n#' a set of distributions equipped with a L2 wasserstein metric.\n#' @param object1  a \\code{MatH} object\n#' @param object2  a \\code{MatH} object\n#' @return a \\code{MatH} object,  \n#' @examples\n#' # binding by row \n#' M1<-BLOOD[1:5,]\n#' M2<-BLOOD[6:10,]\n#' MAT<-WH.mat.sum(M1,M2)\nsetMethod(f=\"WH.mat.sum\",signature=c(object1=\"MatH\",object2=\"MatH\"),\n          #sums two MatH, i.e.  two matrices of distributionsH\n          #INPUT: \n          #OUTPUT: \n          \n          function(object1,object2){\n            nrows1=nrow(object1@M)\n            ncols1=ncol(object1@M)\n            nrows2=nrow(object1@M)\n            ncols2=ncol(object1@M)\n            if (!identical(dim(object1@M),dim(object2@M))){\n              stop(\"the two matrices must be of the same dimension\")}\n            else\n            {\n              MATS=object1\n              TMP=new(\"MatH\",1,2)\n              for (r in 1:nrows1){\n                for (c in 1:ncols1){\n                  TMP@M[1,1][[1]]=object1@M[r,c][[1]]\n                  TMP@M[1,2][[1]]=object2@M[r,c][[1]]\n                  TMP=registerMH(TMP)\n                  MATS@M[r,c][[1]]=new(\"distributionH\",\n                                       (TMP@M[1,1][[1]]@x+TMP@M[1,2][[1]]@x),\n                                       TMP@M[1,1][[1]]@p,\n                                       (TMP@M[1,1][[1]]@m+TMP@M[1,2][[1]]@m))\n                }\n              }\n            }\n            return(MATS)\n          }\n          \n)\n#' @rdname WH.mat.prod-methods\n#' @aliases WH.mat.prod,MatH-method\n#' @description It is the matrix product of two \\code{MatH} objects, i.e. two matrices of distributions, \n#' by using the dot product of two histograms that is consistent with \n#'  a set of distributions equipped with a L2 wasserstein metric.\n#' @param object1  a \\code{MatH} object\n#' @param object2  a \\code{MatH} object\n#' @param ... other optional parameters\n#' @param traspose1 a logical value, default=FALSE. If TRUE trasposes object1\n#' @param traspose2 a logical value, default=FALSE. If TRUE trasposes object2\n#' @return a matrix of numbers  \n#' @examples\n#' \n#' M1<-BLOOD[1:5,]\n#' M2<-BLOOD[6:10,]\n#' MAT<-WH.mat.prod(M1,M2,traspose1=TRUE, traspose2=FALSE)\nsetMethod(f=\"WH.mat.prod\",signature=c(object1=\"MatH\",object2=\"MatH\"),\n          #sums two MatH, i.e.  two matrics of distributionsH\n          #INPUT: \n          #OUTPUT: \n          \n          function(object1,object2,traspose1=FALSE,traspose2=FALSE){\n            if (traspose1==TRUE)\n            {\n              #trasposing the first matrix\n              object1@M=t(object1@M)\n            }\n            if (traspose2==TRUE)\n            {\n              #trasposing the second matrix\n              object2@M=t(object2@M)\n            }\n            nrows1=nrow(object1@M)\n            ncols1=ncol(object1@M)\n            nrows2=nrow(object2@M)\n            ncols2=ncol(object2@M)\n            if (ncols1!=nrows2){\n              cat(\"Fisrt matrix dimensions \", nrow(object1@M), \"x\", ncol(object1@M), \"\\n\",\n                  \"Second matrix dimensions \", nrow(object2@M), \"x\", ncol(object2@M), \"\\n\")\n              stop(\"Dimensions of matrices are not compatible\")}\n            \n            \n            \n            MAT=matrix(0,nrows1,ncols2)\n#             cat(\"Fisrt matrix dimensions \", nrow(object1@M), \"x\", ncol(object1@M), \"\\n\",\n#                 \"Second matrix dimensions \", nrow(object2@M), \"x\", ncol(object2@M), \"\\n\")\n            for (r in 1:nrows1){\n              for (c in 1:ncols2){\n                for (els in 1:ncols1){\n                  MAT[r,c]=MAT[r,c]+dotpW(object1@M[r,els][[1]],object2@M[els,c][[1]])\n                  \n                }\n              }\n            }\n            return(MAT)\n          }\n)\n\n#L2 Wasserstein basic operations and basic statistics for matrices of distributionH ----\n#' Method WH.vec.sum\n#' @name WH.vec.sum\n#' @rdname WH.vec.sum-methods\n#' @exportMethod WH.vec.sum\nsetGeneric(\"WH.vec.sum\",function(object,...) standardGeneric(\"WH.vec.sum\"))#OK weighted sum of a vector of distributionH\n#' Method WH.vec.mean\n#' @name WH.vec.mean\n#' @rdname WH.vec.mean-methods\n#' @exportMethod WH.vec.mean\nsetGeneric(\"WH.vec.mean\",function(object,...) standardGeneric(\"WH.vec.mean\"))#OK weighted mean of a vector of distributionH\n#' Method WH.SSQ\n#' @name WH.SSQ\n#' @rdname WH.SSQ-methods\n#' @exportMethod WH.SSQ\nsetGeneric(\"WH.SSQ\",function(object,...) standardGeneric(\"WH.SSQ\"))#weighted de-codeviance matrix\n#' Method WH.var.covar\n#' @name WH.var.covar\n#' @rdname WH.var.covar-methods\n#' @exportMethod WH.var.covar\nsetGeneric(\"WH.var.covar\",function(object,...) standardGeneric(\"WH.var.covar\"))#weighted variance variance matrix\n#' Method WH.correlation\n#' @name WH.correlation\n#' @rdname WH.correlation-methods\n#' @exportMethod WH.correlation\nsetGeneric(\"WH.correlation\",function(object,...) standardGeneric(\"WH.correlation\"))#weighted corelation matrix\n#' Method WH.SSQ2\n#' @name WH.SSQ2\n#' @rdname WH.SSQ2-methods\n#' @exportMethod WH.SSQ2\nsetGeneric(\"WH.SSQ2\",function(object1,object2,...) standardGeneric(\"WH.SSQ2\"))#weighted de-codeviance matrix\n#' Method WH.var.covar2\n#' @name WH.var.covar2\n#' @rdname WH.var.covar2-methods\n#' @exportMethod WH.var.covar2\nsetGeneric(\"WH.var.covar2\",function(object1,object2,...) standardGeneric(\"WH.var.covar2\"))#weighted variance variance matrix\n#' Method WH.correlation2\n#' @name WH.correlation2\n#' @rdname WH.correlation2-methods\n#' @exportMethod WH.correlation2\nsetGeneric(\"WH.correlation2\",function(object1,object2,...) standardGeneric(\"WH.correlation2\"))#weighted corelation matrix\n\n#' @rdname WH.vec.sum-methods\n#' @aliases WH.vec.sum,MatH-method\n#' @description Compute a histogram that is the weighted sum of the set of histograms contained\n#' in a \\code{MatH} object, i.e. a matrix of histograms, consistent with \n#' a set of distributions equipped with a L2 wasserstein metric.\n#' @param object  a \\code{MatH} object\n#' @param ... optional arguments \n#' @param w it is possible to add a vector of weights (positive numbers) having the same size of the \\code{MatH object}, \n#' default = equal weights for all cells \n#' @return a \\code{distributionH} object, i.e. a histogram  \n#' @examples\n#' hsum<-WH.vec.sum(BLOOD)\n#' # generate a set of random weights\n#' RN<-runif(get.MatH.nrows(BLOOD)*get.MatH.ncols(BLOOD))\n#' hsum<-WH.vec.sum(BLOOD,w=RN)\n\nsetMethod(f=\"WH.vec.sum\",signature=c(object=\"MatH\"),\n          function(object,w=numeric(0)){\n            nrows=nrow(object@M)\n            ncols=ncol(object@M)\n            nelem=nrows*ncols\n            if (missing(w)) {\n              w=rep(1,nelem)\n            } \n            else {\n              if (length(object@M)!=length(w)) \n                stop('Wheights must have the same dimensions of the input matrix of distributions')\n              if (min(w)<0) \n                stop('Weights must be positive!!')\n            }\n            w=matrix(w,nrows,ncols)\n            \n            SUM=new(\"distributionH\",c(0,0),c(0,1))\n            for (c in 1:ncols){\n              for (r in 1:nrows){\n                SUM=SUM+w[r,c]*object@M[r,c][[1]]\n              }\n            }\n            return(SUM)\n          }\n)\n#' @rdname WH.vec.mean-methods\n#' @aliases WH.vec.mean,MatH-method\n#' @description Compute a histogram that is the weighted mean of the set of histograms contained\n#' in a \\code{MatH} object, i.e. a matrix of histograms, consistent with \n#' a set of distributions equipped with a L2 wasserstein metric.\n#' @param object  a \\code{MatH} object\n#' @param ... optional arguments \n#' @param w it is possible to add a vector of weights (positive numbers) having the same size of\n#'  the \\code{MatH object}, default = equal weights for all \n#' @return a \\code{distributionH} object, i.e. a histogram  \n#' @examples\n#' hmean<-WH.vec.mean(BLOOD)\n#' # generate a set of random weights\n#' RN<-runif(get.MatH.nrows(BLOOD)*get.MatH.ncols(BLOOD))\n#' hmean<-WH.vec.mean(BLOOD,w=RN)\n\nsetMethod(f=\"WH.vec.mean\",signature=c(object=\"MatH\"),\n          function(object,w=numeric(0)){\n            #if (length(object@M)==1) return(object)\n            nrows=nrow(object@M)\n            ncols=ncol(object@M)\n            nelem=nrows*ncols\n            if (missing(w)) {\n              w=rep(1/nelem,nelem)\n            } \n            else {\n              if (length(object@M)!=length(w)) \n                stop('Wheights must have the same dimensions of the input matrix of distributions')\n              if (min(w)<0) \n                stop('Weights must be positive!!')\n            }\n            w=matrix(w,nrows,ncols)\n            w=w/sum(w)\n            MEAN=new(\"distributionH\",c(0,0),c(0,1))\n            for (c in 1:ncols){\n              for (r in 1:nrows){\n                MEAN=MEAN+w[r,c]*object@M[r,c][[1]]\n              }\n            }\n            \n            return(MEAN)\n          }\n)\n#' @rdname WH.SSQ-methods\n#' @aliases WH.SSQ,MatH-method\n#' @description Compute the sum-of-squares-deviations (from the mean) matrix of a \\code{MatH} object, i.e. \n#' a matrix of numbers, consistent with \n#' a set of distributions equipped with a L2 wasserstein metric.\n#' @param object  a \\code{MatH} object\n#' @param ... some optional parameters \n#' @param w it is possible to add a vector of weights (positive numbers) \n#' having the same size of the rows of the \\code{MatH object}, \n#' default = equal weight for each row\n#' @return a squared \\code{matrix} with the weighted sum of squares  \n#' @examples\n#' WH.SSQ(BLOOD)\n#' # generate a set of random weights\n#' RN<-runif(get.MatH.nrows(BLOOD))\n#' WH.SSQ(BLOOD,w=RN)\nsetMethod(f=\"WH.SSQ\",signature=c(object=\"MatH\"),\n          function(object,w=numeric(0)){\n            nrows=nrow(object@M)\n            ncols=ncol(object@M)\n            nelem=nrows*ncols\n            if (missing(w)) {\n              w=rep(1,nrows)\n            } \n            else {\n              if (nrows!=length(w)) \n                stop('Wheights must have the same length of rows of the input matrix of distributions')\n              if (min(w)<0) \n                stop('Weights must be positive!!')\n            }\n            w=matrix(w,nrows,1)\n            #w=w/sum(w)\n            DEV_MAT=matrix(0,ncols,ncols)\n            colnames(DEV_MAT)=colnames(object@M)\n            rownames(DEV_MAT)=colnames(object@M)\n            #compute the means\n            MEANS=new(\"MatH\",1,ncols)\n            for (v1 in 1:ncols){\n              MEANS@M[1,v1][[1]]=WH.vec.mean(object[,v1],w)\n            }            \n            for (v1 in 1:ncols){\n              for (v2 in v1:ncols){\n                for (indiv in 1:nrows){\n                  if (v1==v2){\n                    DEV_MAT[v1,v2]=DEV_MAT[v1,v2]+w[indiv,1]*((object@M[indiv,v1][[1]]@s)^2+(object@M[indiv,v1][[1]]@m)^2)\n                  }else{\n                    DEV_MAT[v1,v2]=DEV_MAT[v1,v2]+w[indiv,1]*dotpW(object@M[indiv,v1][[1]],object@M[indiv,v2][[1]])\n                  }\n                }\n                if (v2>v1){\n                  DEV_MAT[v1,v2]=DEV_MAT[v1,v2]-sum(w)*dotpW(MEANS@M[1,v1][[1]],MEANS@M[1,v2][[1]])\n                  DEV_MAT[v2,v1]=DEV_MAT[v1,v2]\n                }else{\n                  DEV_MAT[v1,v1]=DEV_MAT[v1,v1]-sum(w)*(MEANS@M[1,v1][[1]]@s^2+MEANS@M[1,v1][[1]]@m^2)\n                }\n              }\n            }\n            if(ncols==1){\n              return(as.vector(DEV_MAT))\n            }\n            else return(DEV_MAT)\n          }\n)\n#' @rdname WH.var.covar-methods\n#' @aliases WH.var.covar,MatH-method\n#' @description Compute the variance-covariance matrix of a \\code{MatH} object, i.e. \n#' a matrix of values consistent with \n#' a set of distributions equipped with a L2 wasserstein metric.\n#' @param object  a \\code{MatH} object\n#' @param ... some optional parameters \n#' @param w it is possible to add a vector of weights (positive numbers) \n#' having the same size of the rows of the \\code{MatH object}, \n#' default = equal weight for each row\n#' @return a squared \\code{matrix} with the (weighted) variance-covariance values\n#' @references Irpino, A., Verde, R. (2015) \\emph{Basic\n#' statistics for distributional symbolic variables: a new metric-based\n#' approach} Advances in Data Analysis and Classification, DOI\n#' 10.1007/s11634-014-0176-4  \n#' @examples\n#' WH.var.covar(BLOOD)\n#' # generate a set of random weights\n#' RN<-runif(get.MatH.nrows(BLOOD))\n#' WH.var.covar(BLOOD,w=RN)\nsetMethod(f=\"WH.var.covar\",signature=c(object=\"MatH\"),\n          function(object,w=numeric(0)){\n            nrows=nrow(object@M)\n            ncols=ncol(object@M)\n            nelem=nrows*ncols\n            if (missing(w)) {\n              w=rep(1,nrows)\n            } \n            else {\n              if (nrows!=length(w)) \n                stop('Weights must have the same length of rows of the input matrix of distributions')\n              if (min(w)<0) \n                stop('Weights must be positive!!')\n            }\n            w=matrix(w,nrows,1)\n            w=w/sum(w)\n            COV_MAT=WH.SSQ(object,w)\n            return(COV_MAT)\n            \n          }\n)\n#' @rdname WH.correlation-methods\n#' @aliases WH.correlation,MatH-method\n#' @description Compute the correlation matrix of a \\code{MatH} object, i.e. \n#' a matrix of values consistent with \n#' a set of distributions equipped with a L2 wasserstein metric.\n#' @param object  a \\code{MatH} object\n#' @param ... some optional parameters \n#' @param w it is possible to add a vector of weights (positive numbers) \n#' having the same size of the rows of the \\code{MatH object}, \n#' default = equal weight for each row\n#' @return a squared \\code{matrix} with the (weighted) correlations indices\n#' @references Irpino, A., Verde, R. (2015) \\emph{Basic\n#' statistics for distributional symbolic variables: a new metric-based\n#' approach} Advances in Data Analysis and Classification, DOI\n#' 10.1007/s11634-014-0176-4  \n#' @examples\n#' WH.correlation(BLOOD)\n#' # generate a set of random weights\n#' RN<-runif(get.MatH.nrows(BLOOD))\n#' WH.correlation(BLOOD,w=RN)\nsetMethod(f=\"WH.correlation\",signature=c(object=\"MatH\"),\n          function(object,w=numeric(0)){\n            nrows=nrow(object@M)\n            ncols=ncol(object@M)\n            nelem=nrows*ncols\n            if (missing(w)) {\n              w=rep(1,nrows)\n            } \n            else {\n              if (nrows!=length(w)) \n                stop('Wheights must have the same length of rows of the input matrix of distributions')\n              if (min(w)<0) \n                stop('Weights must be positive!!')\n            }\n            w=matrix(w,nrows,1)\n            w=w/sum(w)\n            COV_MAT=WH.var.covar(object,w)\n            CORR_MAT=as.matrix(COV_MAT)\n            \n            for (v1 in 1:ncols){\n              for (v2 in v1:ncols){\n                CORR_MAT[v1,v2]= COV_MAT[v1,v2]/sqrt((COV_MAT[v1,v1]*COV_MAT[v2,v2]))\n                CORR_MAT[v2,v1]=CORR_MAT[v1,v2]\n              }\n            }\n            return(CORR_MAT)\n            \n          }\n)\n#' @rdname WH.SSQ2-methods\n#' @aliases WH.SSQ2,MatH-method\n#' @description Compute the sum-of-squares-deviations (from the mean) matrix using two  \\code{MatH} objects having the same number of rows,\n#'  It returns a rectangular a matrix of numbers, consistent with \n#' a set of distributions equipped with a L2 wasserstein metric.\n#' @param object1  a \\code{MatH} object\n#'  @param object2  a \\code{MatH} object\n#'  @param ... some optional parameters \n#' @param w it is possible to add a vector of weights (positive numbers) \n#' having the same size of the rows of the \\code{MatH object}, \n#' default = equal weight for each row\n#' @return a rectangular \\code{matrix} with the weighted sum of squares  \n#' @examples\n#' M1<-BLOOD[,1]\n#' M2<-BLOOD[,2:3]\n#' WH.SSQ2(M1,M2)\n#' # generate a set of random weights\n#' RN<-runif(get.MatH.nrows(BLOOD))\n#' WH.SSQ2(M1,M2,w=RN)\nsetMethod(f=\"WH.SSQ2\",signature=c(object1=\"MatH\",object2=\"MatH\"),\n          function(object1, object2, w=numeric(0)){\n            nrows1=nrow(object1@M)\n            ncols1=ncol(object1@M)\n            \n            nrows2=nrow(object2@M)\n            ncols2=ncol(object2@M)\n            \n            if (nrows1!=nrows2){stop('The two matrices have a different number of rows')}\n            \n            if (missing(w)) {\n              w=rep(1,nrows1)\n            } \n            else {\n              if (nrows1!=length(w)) \n                stop('Wheights must have the same length of rows of the input matrix of distributions')\n              if (min(w)<0) \n                stop('Weights must be positive!!')\n            }\n            w=matrix(w,nrows1,1)\n            #w=w/sum(w)\n            DEV_MAT=matrix(0,ncols1,ncols2)\n            rownames(DEV_MAT)=colnames(object1@M)\n            colnames(DEV_MAT)=colnames(object2@M)\n            \n            #compute the means\n            MEANS1=new(\"MatH\",1,ncols1)\n            for (v1 in 1:ncols1){\n              MEANS1@M[1,v1][[1]]=WH.vec.mean(object1[,v1],w)\n            }\n            MEANS2=new(\"MatH\",1,ncols2)\n            for (v2 in 1:ncols2){\n              MEANS2@M[1,v2][[1]]=WH.vec.mean(object2[,v2],w)\n            }\n            \n            \n            for (v1 in 1:ncols1){\n              for (v2 in 1:ncols2){\n                for (indiv in 1:nrows1){\n                  DEV_MAT[v1,v2]=DEV_MAT[v1,v2]+w[indiv,1]*dotpW(object1@M[indiv,v1][[1]],object2@M[indiv,v2][[1]])\n                }\n                \n                DEV_MAT[v1,v2]=DEV_MAT[v1,v2]-sum(w)*dotpW(MEANS1@M[1,v1][[1]],MEANS2@M[1,v2][[1]])\n              }\n            }\n            if(ncols1==1&&ncols2==1){\n              return(as.vector(DEV_MAT))\n            }\n            else return(DEV_MAT)\n          }\n)\n#' @rdname WH.var.covar2-methods\n#' @aliases WH.var.covar2,MatH-method\n#' @description Compute the covariance matrix using two  \\code{MatH} objects having the same number of rows,\n#'  It returns a rectangular a matrix of numbers, consistent with \n#' a set of distributions equipped with a L2 wasserstein metric.\n#' @param object1  a \\code{MatH} object\n#'  @param object2  a \\code{MatH} object\n#' @param ... some optional parameters \n#' @param w it is possible to add a vector of weights (positive numbers) \n#' having the same size of the rows of the \\code{MatH object}, \n#' default = equal weight for each row\n#' @return a rectangular \\code{matrix} with the weighted sum of squares  \n#' @examples\n#' M1<-BLOOD[,1]\n#' M2<-BLOOD[,2:3]\n#' WH.var.covar2(M1,M2)\n#' # generate a set of random weights\n#' RN<-runif(get.MatH.nrows(BLOOD))\n#' WH.var.covar2(M1,M2,w=RN)\nsetMethod(f=\"WH.var.covar2\",signature=c(object1=\"MatH\",object2=\"MatH\"),\n          function(object1, object2, w=numeric(0)){\n            nrows1=nrow(object1@M)\n            ncols1=ncol(object1@M)\n            \n            nrows2=nrow(object2@M)\n            ncols2=ncol(object2@M)\n            \n            if (nrows1!=nrows2){stop('The two matrices have a different number of rows')}\n            \n            if (missing(w)) {\n              w=rep(1,nrows1)\n            } \n            else {\n              if (nrows1!=length(w)) \n                stop('Wheights must have the same length of rows of the input matrix of distributions')\n              if (min(w)<0) \n                stop('Weights must be positive!!')\n            }\n            w=matrix(w,nrows1,1)\n            w=w/sum(w)\n            VAR_MAT=matrix(0,ncols1,ncols2)\n            rownames(VAR_MAT)=colnames(object1@M)\n            colnames(VAR_MAT)=colnames(object2@M)\n            \n            #compute the means\n            MEANS1=new(\"MatH\",1,ncols1)\n            for (v1 in 1:ncols1){\n              MEANS1@M[1,v1][[1]]=WH.vec.mean(object1[,v1],w)\n            }\n            MEANS2=new(\"MatH\",1,ncols2)\n            for (v2 in 1:ncols2){\n              MEANS2@M[1,v2][[1]]=WH.vec.mean(object2[,v2],w)\n            }\n            \n            \n            for (v1 in 1:ncols1){\n              for (v2 in 1:ncols2){\n                for (indiv in 1:nrows1){\n                  VAR_MAT[v1,v2]=VAR_MAT[v1,v2]+w[indiv,1]*dotpW(object1@M[indiv,v1][[1]],object2@M[indiv,v2][[1]])\n                }\n                \n                VAR_MAT[v1,v2]=VAR_MAT[v1,v2]-sum(w)*dotpW(MEANS1@M[1,v1][[1]],MEANS2@M[1,v2][[1]])\n              }\n            }\n            if(ncols1==1&&ncols2==1){\n              return(as.vector(VAR_MAT))\n            }\n            else return(VAR_MAT)\n          }\n)\n#' @rdname WH.correlation2-methods\n#' @aliases WH.correlation2,MatH-method\n#' @description Compute the correlation matrix using two  \\code{MatH} objects having the same number of rows,\n#'  It returns a rectangular a matrix of numbers, consistent with \n#' a set of distributions equipped with a L2 wasserstein metric.\n#' @param object1  a \\code{MatH} object\n#'  @param object2  a \\code{MatH} object\n#' @param ... some optional parameters \n#' @param w it is possible to add a vector of weights (positive numbers) \n#' having the same size of the rows of the \\code{MatH object}, \n#' default = equal weight for each row\n#' @return a rectangular \\code{matrix} with the weighted sum of squares  \n#' @examples\n#' M1<-BLOOD[,1]\n#' M2<-BLOOD[,2:3]\n#' WH.correlation2(M1,M2)\n#' # generate a set of random weights\n#' RN<-runif(get.MatH.nrows(BLOOD))\n#' WH.correlation2(M1,M2,w=RN)\nsetMethod(f=\"WH.correlation2\",signature=c(object1=\"MatH\",object2=\"MatH\"),\n          function(object1, object2, w=numeric(0)){\n            nrows1=nrow(object1@M)\n            ncols1=ncol(object1@M)\n            \n            nrows2=nrow(object2@M)\n            ncols2=ncol(object2@M)\n            \n            if (nrows1!=nrows2){stop('The two matrices have a different number of rows')}\n            \n            if (missing(w)) {\n              w=rep(1,nrows1)\n            } \n            else {\n              if (nrows1!=length(w)) \n                stop('Wheights must have the same length of rows of the input matrix of distributions')\n              if (min(w)<0) \n                stop('Weights must be positive!!')\n            }\n            w=matrix(w,nrows1,1)\n            w=w/sum(w)\n            COV_MAT=WH.var.covar2(object1,object2,w)\n            CORR_MAT=as.matrix(COV_MAT)\n            \n            for (v1 in 1:ncols1){\n              for (v2 in 1:ncols2){\n                CORR_MAT[v1,v2]= COV_MAT[v1,v2]/sqrt(WH.var.covar(object1[,v1],w)*WH.var.covar(object2[,v2],w))\n              }\n            }\n            if (length(CORR_MAT)==1) return(as.vector(CORR_MAT)) \n            else return(CORR_MAT)\n            \n          }\n)\n\n# Utility methods for registration of distributions ----\n#' Method is.registeredMH\n#' @name is.registeredMH\n#' @rdname is.registeredMH-methods\n#' @exportMethod is.registeredMH\nsetGeneric(\"is.registeredMH\",function(object) standardGeneric(\"is.registeredMH\"))#OK\n#' @rdname is.registeredMH-methods\n#' @aliases is.registeredMH,MatH-method\n#' @description Checks if a \\code{MatH} contains histograms described by the same number of\n#' bins and the same cdf.\n#' \n#' @param object A \\code{MatH} object\n#' @return a \\code{logical} value \\code{TRUE} if the distributions share the\n#' same cdf, \\code{FALSE} otherwise.\n#' @author Antonio Irpino\n#' @references Irpino, A., Lechevallier, Y. and Verde, R. (2006): \\emph{Dynamic\n#' clustering of histograms using Wasserstein metric} In: Rizzi, A., Vichi, M.\n#' (eds.) COMPSTAT 2006. Physica-Verlag, Berlin, 869-876.\\cr Irpino, A.,Verde,\n#' R. (2006): \\emph{A new Wasserstein based distance for the hierarchical\n#' clustering of histogram symbolic data} In: Batanjeli, V., Bock, H.H.,\n#' Ferligoj, A., Ziberna, A. (eds.) Data Science and Classification, IFCS 2006.\n#' Springer, Berlin, 185-192.\n#' @keywords distribution\n#' @examples\n#' \n#' ##---- initialize three distributionH objects mydist1 and mydist2\n#'  mydist1=new(\"distributionH\",c(1,2,3),c(0, 0.4, 1))\n#'  mydist2=new(\"distributionH\",c(7,8,10,15),c(0, 0.2, 0.7, 1))\n#'  mydist3=new(\"distributionH\",c(9,11,20),c(0, 0.8, 1))\n#'  ## create a MatH object\n#'  MyMAT=new(\"MatH\",nrows=1,ncols=3,ListOfDist=c(mydist1,mydist2,mydist3), 1,3)\n#'  is.registeredMH(MyMAT)\n#'  ## [1] FALSE #the distributions do not share the same cdf \n#'  ## Hint: check with str(MyMAT)\n#'  \n#'  ## register the two distributions\n#'  MATregistered=registerMH(MyMAT)\n#'  is.registeredMH(MATregistered)\n#'  ## TRUE #the distributions share the same cdf\n#'  ## Hint: check with str(MATregistered)\n#' \nsetMethod(f=\"is.registeredMH\",signature=c(object=\"MatH\"),\n          #check if all the distributions share the same cdf\n          #INPUT: object11  - a vector or a matrix two distributions\n          #OUTPUT: resu - a matrix of distributionH objects with\n          #recomputed quantiles on a common cdf\n          function(object){\n            nrows=nrow(object@M)\n            ncols=ncol(object@M)\n            ndis=nrows*ncols\n            #Check if the distribution are registered\n            OK=1;\n            count=1\n            r=1\n            tmpcdf=object@M[1,1][[1]]@p\n            while (OK==1){\n              count=count+1\n              if (count<=ndis){\n                if (!identical(tmpcdf,object@M[count][[1]]@p)) {\n                  OK=0\n                  return(FALSE)\n                }\n              }\n              else {\n                OK=0\n                return(TRUE)\n              }\n            }\n          }\n)\n#' Method registerMH\n#' @name registerMH\n#' @rdname registerMH-methods\n#' @exportMethod registerMH\nsetGeneric(\"registerMH\",function(object) standardGeneric(\"registerMH\"))#OK\n#' @rdname registerMH-methods\n#' @aliases registerMH,MatH-method\n#' @description \\code{registerMH} method registers a set of distributions of a \\code{MatH} object\n#' All the\n#' distribution are recomputed to obtain distributions sharing the same\n#' \\code{p} slot. This methods is useful for using fast computation of all\n#' methods based on L2 Wasserstein metric. The distributions will have the same\n#' number of element in the \\code{x} slot without modifing their density\n#' function.\n#' \n#' \n#' @param object  A \\code{MatH} object (a matrix of distributions)\n#' @return A \\code{MatH} object, a matrix of distributions sharing the same\n#' \\code{p} slot (i.e. the same cdf).\n#' @author Antonio Irpino\n#' @references Irpino, A., Lechevallier, Y. and Verde, R. (2006): \\emph{Dynamic\n#' clustering of histograms using Wasserstein metric} In: Rizzi, A., Vichi, M.\n#' (eds.) COMPSTAT 2006. Physica-Verlag, Berlin, 869-876.\\cr Irpino, A.,Verde,\n#' R. (2006): \\emph{A new Wasserstein based distance for the hierarchical\n#' clustering of histogram symbolic data} In: Batanjeli, V., Bock, H.H.,\n#' Ferligoj, A., Ziberna, A. (eds.) Data Science and Classification, IFCS 2006.\n#' Springer, Berlin, 185-192.\n#' @keywords distribution\n#' @examples\n#'#initialize three distributionH objects mydist1 and mydist2 \n#'  mydist1=new(\"distributionH\",c(1,2,3),c(0, 0.4, 1))\n#'  mydist2=new(\"distributionH\",c(7,8,10,15),c(0, 0.2, 0.7, 1))\n#'  mydist3=new(\"distributionH\",c(9,11,20),c(0, 0.8, 1))\n#'# create a MatH object\n#'\n#'  MyMAT=new(\"MatH\",nrows=1,ncols=3,ListOfDist=c(mydist1,mydist2,mydist3), 1,3)\n#'# register the two distributions\n#'   MATregistered=registerMH(MyMAT)\n#  \n#'# OUTPUT the structure of MATregstered\n#' str(MATregistered)\n#'#   Formal class 'MatH' [package \"HistDAWass\"] with 1 slots\n#'#   .. @@ M:List of 3\n#'#   .. ..$ :Formal class 'distributionH' [package \"HistDAWass\"] with 4 slots\n#'#   .. .. .. ..@@ x: num [1:6] 1 1.5 2 2.5 2.67 ...\n#'#   .. .. .. ..@@ p: num [1:6] 0 0.2 0.4 0.7 0.8 1\n#'#   ...\n#'#   .. ..$ :Formal class 'distributionH' [package \"HistDAWass\"] with 4 slots\n#'#   .. .. .. ..@@ x: num [1:6] 7 8 8.8 10 11.7 ...\n#'#   .. .. .. ..@@ p: num [1:6] 0 0.2 0.4 0.7 0.8 1\n#'#   ...\n#'#   .. ..$ :Formal class 'distributionH' [package \"HistDAWass\"] with 4 slots\n#'#   .. .. .. ..@@ x: num [1:6] 9 9.5 10 10.8 11 ...\n#'#   .. .. .. ..@@ p: num [1:6] 0 0.2 0.4 0.7 0.8 1\n#'#   ...\n#'#   .. ..- attr(*, \"dim\")= int [1:2] 1 3\n#'#   .. ..- attr(*, \"dimnames\")=List of 2\n#'#   .. .. ..$ : chr \"I1\"\n#'#   .. .. ..$ : chr [1:3] \"X1\" \"X2\" \"X3\"\n# \nsetMethod(f=\"registerMH\",signature=c(object=\"MatH\"),\n          #register a row or a column vector of qfs of distributionH:\n          #if the cdf are different a a matrix resu is returned with the quantiles of the two\n          #distribution computed at the same levels of a common vector of cdfs.\n          #INPUT: object11  - a vector or a matrix two distributions\n          #OUTPUT: resu - a matrix of distributionH objects with\n          #recomputed quantiles on a common cdf\n          function(object){\n            nrows=nrow(object@M)\n            ncols=ncol(object@M)\n            ndis=nrows*ncols\n            #Check if the distributions are registered\n            if (is.registeredMH(object)){return(object)}\n            commoncdf=numeric(0)\n            for (i in 1:nrows){\n              for (j in 1:ncols){\n                commoncdf=rbind(commoncdf,t(t(object@M[i,j][[1]]@p)))\n              }\n            }\n            commoncdf=sort(unique(commoncdf))\n            #check for tiny bins and for very long vectors of wheights\n            diffs=commoncdf[2:length(commoncdf)]-commoncdf[1:(length(commoncdf)-1)]\n            diffs[which(diffs<1e-8)]=0\n            commoncdf=sort(unique(cumsum(x = c(0,diffs))))\n            commoncdf=commoncdf/commoncdf[length(commoncdf)]\n#             todelete=which(diffs<1e-8)\n#             if (length(todelete)>0){\n#               commoncdf=as.vector(commoncdf[-todelete,1])\n#               if (coomoncdf[length(commoncdf)]<1){\n#                 coomoncdf=c(commoncdf,1)\n#               }\n#             }\n            #end of check\n            nr=length(commoncdf)\n            result=matrix(0,nr,(ndis+1))\n            result[,(ndis+1)]=commoncdf\n            NEWMAT=new(\"MatH\",nrows,ncols)  \n            for (r in 1:nrows){\n              for (c in 1:ncols){\n                x=numeric(0)\n                for (rr in 1:nr){\n                  x=c(x,compQ(object@M[r,c][[1]],commoncdf[rr]))  \n                }\n                NEWMAT@M[r,c][[1]]=new(\"distributionH\",x,commoncdf)\n              }\n            }\n            return(NEWMAT)\n          }\n)\n## Show overridding ----\n#' Method show for MatH\n#' @name show-MatH\n#' @rdname show-MatH-methods\n#' @docType methods\n# @aliases show,distributionH-method\n# @name show\n# @rdname show-MatH\n#' @aliases show,MatH-method \n#' @description An overriding show method for a \\code{MatH} object. The method returns a representation \n#' of the matrix using the mean and the standard deviation for each histogram. \n#' @param object  a \\code{MatH} object\n#' @examples\n#' show(BLOOD)\n#' print(BLOOD)\n#' BLOOD\nsetMethod(\"show\",\n          signature(object=\"MatH\"),\n          definition = function(object){\n            cat(\"a matrix of distributions \\n\", paste(ncol(object@M),\" variables \",\n                                                     nrow(object@M), \" rows \\n\" ), \"each distibution in the cell is represented by the mean and the standard deviation \\n \")\n            mymat=matrix(0,nrow(object@M)+1,ncol(object@M))\n            for (i in 1:ncol(object@M)){mymat[1,i]=colnames(object@M)[i]}\n            for (i in 1:nrow(object@M)){\n              for (j in 1:ncol(object@M)){\n                if(length(object@M[i,j][[1]]@x)==0){\n                  mymat[i+1,j]=paste(\"Empty distribution\")\n                }\n                else{\n                  if ((abs(object@M[i,j][[1]]@m)>1e5 || abs(object@M[i,j][[1]]@m)<1e-5)&&\n                        (object@M[i,j][[1]]@s>1e5 || object@M[i,j][[1]]@s<1e-5))  {\n                    mymat[i+1,j]=paste(\"[m=\",format(object@M[i,j][[1]]@m,digits=5,scientific=TRUE),\n                                       \" ,s=\",format(object@M[i,j][[1]]@s,digits=5,scientific=TRUE),\"]\")\n                  }\n                  if ((abs(object@M[i,j][[1]]@m)<=1e5 && abs(object@M[i,j][[1]]@m)>=1e-5)&&\n                        (object@M[i,j][[1]]@s<=1e5 || object@M[i,j][[1]]@s>=1e-5))  {\n                    mymat[i+1,j]=paste(\"[m=\",format(object@M[i,j][[1]]@m,digits=5),\n                                       \" ,s=\",format(object@M[i,j][[1]]@s,digits=5),\"]\")\n                  }\n                  if ((abs(object@M[i,j][[1]]@m)>1e5 || abs(object@M[i,j][[1]]@m)<1e-5)&&\n                        (object@M[i,j][[1]]@s<=1e5 && object@M[i,j][[1]]@s>=1e-5)) {\n                    mymat[i+1,j]=paste(\"[m=\",format(object@M[i,j][[1]]@m,digits=5,scientific=TRUE),\n                                       \" ,s=\",format(object@M[i,j][[1]]@s,digits=5),\"]\")\n                  }\n                  if ((abs(object@M[i,j][[1]]@m)<=1e5 && abs(object@M[i,j][[1]]@m)>=1e-5)&&\n                        (object@M[i,j][[1]]@s>1e5 || object@M[i,j][[1]]@s<1e-5))  {\n                    mymat[i+1,j]=paste(\"[m=\",format(object@M[i,j][[1]]@m,digits=5),\n                                       \" ,s=\",format(object@M[i,j][[1]]@s,digits=5,scientific=TRUE),\"]\")\n                  }\n                }\n              }\n            }\n            \n            rownames(mymat)=c(\n              paste(rep(\" \",nchar(rownames(object@M)[1])),collapse=\"\"),\n              row.names(object@M))\n            write.table(format(mymat,justify=\"centre\"),row.names=T, col.names=F,quote=F)\n          }\n)\n if (!isGeneric(\"plot\")) { \n   setGeneric(\"plot\", \n              function(x, y, ...) standardGeneric(\"plot\")) \n } \n## --- Plot overloading\n#' Method plot for a matrix  of histograms\n#' @name plot-MatH\n#' @docType methods\n#' @rdname plot-MatH\n#' @aliases plot,MatH-method\n#' @description An overloading plot function for a \\code{MatH} object. The method returns a graphical representation \n#' of the matrix of histograms. \n\n#' @param x a \\code{distributionH} object\n#' @param y not used in this implementation\n#' @param type (optional) a string describing the type of plot, default=\"HISTO\".\\cr\n#'  Other allowed types are \\cr\n#'  \"DENS\"=a density approximation, \\cr\n#'  \"BOXPLOT\"=l boxplot\n#'  @param col (optional) a string the color of the plot, default=\"green\".\n#'  @param border (optional) a string the color of the border of the plot, default=\"black\".\n#' @examples\n#'  plot(BLOOD) #plots BLOOD dataset\n#'  plot(BLOOD, type=\"HISTO\", col=\"red\", border=\"blue\") #plots a matrix of histograms\n#'  plot(BLOOD, type=\"DENS\", col=\"red\", border=\"blue\") #plots a matrix of densities\n#'  plot(BLOOD, type=\"BOXPLOT\") #plots a  boxplots\n#'  @export\n\nsetMethod(\"plot\",\n          signature(x = \"MatH\"),\n          function (x, y=\"missing\", type=\"HISTO\",col=\"green\",border=\"black\") \n          {\n            parold=par(no.readonly=TRUE)\n            varsno=ncol(x@M)\n            indno=nrow(x@M)\n            lims=matrix(c(Inf,-Inf),2,varsno)\n            if (varsno==1 && indno==1){\n              tmpo=x@M[1,1][[1]]\n              plot(tmpo,type=type,col=col,border=border)\n            }\n            else{\n              for (i in 1:indno){\n                for (j  in 1:varsno){\n                  if (x@M[i,j][[1]]@x[1]<lims[1,j]) {\n                    lims[1,j]=x@M[i,j][[1]]@x[1]\n                  }\n                  if (x@M[i,j][[1]]@x[length(x@M[i,j][[1]]@x)]>lims[2,j]) {\n                    lims[2,j]=x@M[i,j][[1]]@x[length(x@M[i,j][[1]]@x)]\n                  }\n                }\n              }\n              \n              par(mfrow=c(indno+2,varsno+1),mar=c(0.1,0.1,0.1,0.1),oma=(c(0,0,0,0)))\n              plot(0:5,0:5,type=\"n\",yaxt=\"n\",xaxt=\"n\")\n              text(2,2,\"Objects\")\n              for (j  in 1:varsno){\n                plot(0:5,0:5,type=\"n\",yaxt=\"n\",xaxt=\"n\")\n                text(2,2,variable.names(x@M)[j])\n              }\n              for (i in 1:indno){\n                plot(0:5,0:5,type=\"n\",yaxt=\"n\",xaxt=\"n\")\n                text(2,2,row.names(x@M)[i])\n                for (j  in 1:varsno){\n                  tmpo=x@M[i,j][[1]]\n                  xlabel=paste(\"m= \",tmpo@m,\" std= \",tmpo@s)\n                  \n                  if (type==\"HISTO\"){\n                    lowers=tmpo@x[1:(length(tmpo@x)-1)]\n                    uppers=tmpo@x[2:length(tmpo@x)]\n                    ampl=uppers-lowers\n                    dens=(tmpo@p[2:length(tmpo@p)]-tmpo@p[1:(length(tmpo@p)-1)])/ampl\n                    plot(c(lims[1,j],lims[2,j]), c(0,max(dens[dens<Inf]))*1.1, type= \"n\", xlab = \"\", ylab = \"\",yaxt=\"n\",xaxt=\"n\")\n#                     if (length(ampl[ampl==0])>0){\n#                     ampl[ampl==0]=1\n#                     dens=(tmpo@p[2:length(tmpo@p)]-tmpo@p[1:(length(tmpo@p)-1)])/ampl}\n                    for (r in 1:length(lowers)){\n                      if (ampl[r]==0){segments(lowers[r],0,lowers[r],1)}else{\n                      rect(lowers[r], 0, uppers[r], dens[r], col = col, border = border)}\n                    }\n                  }\n                  \n                  if (type==\"DENS\"){\n                    #generate 100 random points according to the QF\n                    rn=100\n                    \n                   \n                    xn=c(rep(0,rn))\n                    random_no=c(0:rn)/rn\n                    for (k in 1:rn){\n                      xn[k]=compQ(tmpo,random_no[k])\n                    }\n                    d <- density(xn)\n                    plot(c(lims[1,j],lims[2,j]), c(0,max(d$y)), type= \"n\",  xlab =\"\", ylab = \"\",yaxt=\"n\",xaxt=\"n\")\n                    polygon(d$x,d$y, col=col, border=border)\n                  }\n                  if (type==\"BOXPLOT\"){\n                    qua=c(0,0.25,0.5,0.75,1)\n                    xn=c(0,0,0,0,0)\n                    for (k in 1:5){\n                      xn[k]=compQ(tmpo,qua[k])\n                    }\n                    plot(c(lims[1,j],lims[2,j]), c(0.7,2.3), type= \"n\", xlab =\"\", ylab = \"\",yaxt=\"n\",xaxt=\"n\")\n                    \n                    rect(xn[2], 1, xn[3], 2, col = col, border = border)\n                    rect(xn[3], 1, xn[4], 2, col = col, border = border)\n                    segments(xn[1], 1.5, xn[2], 1.5,col=\"black\")\n                    segments(xn[4], 1.5, xn[5], 1.5,col=\"black\")\n                    segments(xn[1], 1, xn[1], 2,col=\"black\")\n                    segments(xn[5], 1, xn[5], 2,col=\"black\")\n                  }\n                  if (type==\"CDF\"){\n                    xs=tmpo@x\n                    ps=tmpo@p\n                    plot(c(lims[1,j],lims[2,j]), c(0,1), type= \"n\", xlab = \"\", ylab = \"\",yaxt=\"n\",xaxt=\"n\")\n                    lines(xs,ps,col=border)\n                  }    \n                }\n              }\n              plot(0:5,0:5,type=\"n\",yaxt=\"n\",xaxt=\"n\", axes=F)\n              text(2,2,\"\")\n              for (j  in 1:varsno){\n                plot(c(lims[1,j],lims[2,j]), c(0,2), type= \"n\", xlab = \"\", ylab = \"\",yaxt=\"n\",xaxt=\"n\", axes=F)\n                segments(lims[1,j],1.2, lims[1,j],1.4,col=\"black\")\n                text(lims[1,j],0.7,format(lims[1,j]))\n                segments(0.5*lims[1,j]+0.5*lims[2,j],1.2, \n                         0.5*lims[1,j]+0.5*lims[2,j],1.4,col=\"black\")\n                text(0.5*lims[1,j]+0.5*lims[2,j],0.7,format(0.5*lims[1,j]+0.5*lims[2,j]))\n                segments(0.25*lims[1,j]+0.75*lims[2,j],1.2, \n                         0.25*lims[1,j]+0.75*lims[2,j],1.4,col=\"black\")\n                text(0.25*lims[1,j]+0.75*lims[2,j],0.7,format(0.25*lims[1,j]+0.75*lims[2,j]))\n                segments(0.75*lims[1,j]+0.25*lims[2,j],1.2, \n                         0.75*lims[1,j]+0.25*lims[2,j],1.4,col=\"black\")\n                text(0.75*lims[1,j]+0.25*lims[2,j],0.7,format(0.75*lims[1,j]+0.25*lims[2,j]))\n                segments(lims[2,j],1.2, lims[2,j],1.4,col=\"black\")\n                text(lims[2,j],0.7,format(lims[2,j]))\n                \n                segments(lims[1,j],1.3, lims[2,j],1.3,col=\"black\")\n                \n              }\n              par(parold)\n            }\n          }\n)\n",
    "created" : 1424119960452.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2365062203",
    "id" : "2E99E657",
    "lastKnownWriteTime" : 1424174823,
    "path" : "C:/Users/Antonio/Desktop/HISTO_R_PACK/HistDAWass/R/Met_MatH.R",
    "project_path" : "R/Met_MatH.R",
    "properties" : {
    },
    "source_on_save" : true,
    "type" : "r_source"
}