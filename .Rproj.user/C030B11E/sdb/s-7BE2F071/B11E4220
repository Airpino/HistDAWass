{
    "contents" : "#Constructor\n#' Wrapper function distributionH\n#' \n#' A histogram object can be created also with the function \\code{distributionH(...)}, the costructor function for creating an object containing the description of\n#' a histogram.\n#' \n#' @name distributionH\n#' @rdname distributionH-class\n#' @export\n#' @return A \\code{distributionH} object\n#' @examples\n#' # or using\n#' mydist=distributionH(x=c(1,2,3),p=c(0,0.4, 1))\ndistributionH=function(x=numeric(0),p=numeric(0)){\n  object=new(\"distributionH\",x=x,p=p)\n  return(object)\n}\n\n#Get\n\n#' Method \\code{get.m}\n#' @name get.m\n#' @rdname get.m-methods\n#' @exportMethod get.m\nsetGeneric(\"get.m\", function(object) standardGeneric(\"get.m\"))\n#' @rdname get.m-methods\n#' @aliases get.m,distributionH-method\n#' @description This functon return the mean of a \\code{distributionH} object.\n#' @param object a \\code{distributionH} object\n#' @return A numeric value\n#' @examples\n#' D=distributionH(x=c(1,2,3,4),p=c(0,0.2,0.6, 1))\n#' get.m(D) #returns the mean of D\nsetMethod(\"get.m\",\"distributionH\",\n          function(object){\n            if (!is.null(object)){\n              return(object@m)\n            }  else\n              return(NA)\n          }\n)\n\n#' Method \\code{get.s}\n#' @name get.s\n#' @rdname get.s-methods\n#' @exportMethod get.s\nsetGeneric(\"get.s\", function(object) standardGeneric(\"get.s\"))\n\n#' @rdname get.s-methods\n#' @aliases get.s,distributionH-method\n#' @description This functon return the standard deviation of a \\code{distributionH} object.\n#' @param object a \\code{distributionH} object.\n#' @return A numeric positive value, the standard deviation.\n#' @examples\n#' D=distributionH(x=c(1,2,3,4),p=c(0,0.2,0.6, 1))\n#' get.s(D) # returns the standard deviation of D\nsetMethod(\"get.s\",\"distributionH\",\n          function(object){\n            if (!is.null(object)){\n              return(object@s)\n            }  else\n              return(NA)\n          }\n)\n#' Method \\code{get.distr}\n#' @name get.distr\n#' @rdname get.distr-methods\n#' @exportMethod get.distr\nsetGeneric(\"get.distr\", function(object) standardGeneric(\"get.distr\"))\n\n#' @rdname get.distr-methods\n#' @aliases get.distr,distributionH-method\n#' @description This functon return the cumulative distribution function of a \\code{distributionH} object.\n#' @param object a \\code{distributionH} object.\n#' @return A data frame: the first column contains the domain the second the CDF values.\n#' @examples\n#' D=distributionH(x=c(1,2,3,4),p=c(0,0.2,0.6, 1))\n#' get.distr(D) #a data.frame describing the CDF of D\nsetMethod(\"get.distr\",\"distributionH\",\n          function(object){\n            if (!is.null(object)){\n              MAT=cbind(object@x,object@p)\n              colnames(MAT)=c('x','p')\n              return(MAT=as.data.frame(MAT))\n            }  else\n              return(NA)\n          }\n)\n#' Method \\code{get.histo}\n#' @name get.histo\n#' @rdname get.histo-methods\n#' @exportMethod get.histo\nsetGeneric(\"get.histo\", function(object) standardGeneric(\"get.histo\"))\n\n# Get the distribution of a histogram\n#' @rdname get.histo-methods\n#' @aliases get.histo,distributionH-method\n#' @description This functon return a data.frame describing the histogram of a \\code{distributionH} object.\n#' @param object a \\code{distributionH} object.\n#' @return A matrix: the two columns contains the bounds of the histogram the third contains the probablity (or the relative frequency) of the bin.\n#' @examples\n#' D=distributionH(x=c(1,2,3,4),p=c(0,0.2,0.6, 1))\n#' get.histo(D) #returns the histogram representation of D by a data.frame\nsetMethod(\"get.histo\",\"distributionH\",\n          function(object){\n            if (!is.null(object)){\n              M=get.distr(object)\n              MAT=cbind(M$x[1:(length(M$x)-1)], \n                        M$x[2:length(M$x)],\n                        M$p[2:length(M$p)]-M$p[1:(length(M$p)-1)])\n              colnames(MAT)=c('min.x','max.x', 'p')\n              return(MAT=as.data.frame(MAT))\n            }  else\n              return(NA)\n          }\n)\n\n# Basic statistics of distributions --------\n#' Method \\code{meanH}\n#' @name meanH\n#' @rdname meanH-methods\n#' @exportMethod meanH\nsetGeneric(\"meanH\", function(object) standardGeneric(\"meanH\"))\n#' Method \\code{stdH}\n#' @name stdH\n#' @rdname stdH-methods\n#' @exportMethod stdH\nsetGeneric( \"stdH\", function(object) standardGeneric(\"stdH\"))\n#' Method \\code{skewH}\n#' @name skewH\n#' @rdname skewH-methods\n#' @exportMethod skewH\nsetGeneric(\"skewH\", function(object) standardGeneric(\"skewH\"))\n#' Method \\code{kurtH}\n#' @name kurtH\n#' @rdname kurtH-methods\n#' @exportMethod kurtH\nsetGeneric(\"kurtH\", function(object) standardGeneric(\"kurtH\"))\n#' Method \\code{crwtransform}\n#' @name crwtransform\n#' @rdname crwtransform-methods\n#' @exportMethod crwtransform\nsetGeneric(\"crwtransform\", function(object) standardGeneric(\"crwtransform\"))\n\n#' @rdname meanH-methods\n#' @aliases meanH,distributionH-method \n#' @description Mean of a histogram (First moment of the distribution)\n#' @param object a \\code{distributionH} object\n#' @return the mean of the distribution\n#' @author Antonio Irpino\n#' @keywords distribution\n#' @examples\n#' \n#' ##---- A mydist distribution ----\n#' mydist<-distributionH(x=c(1,2,3,10), p=c(0,0.1,0.5,1))\n#' ##---- Compute the mean of mydist ----\n#' meanH(mydist) #---> 4.4\n#'\nsetMethod(\"meanH\",\"distributionH\",\n          function(object){\n            if (!is.null(object@x)||!is.null(object@p)){\n              resu=crwtransform(object)\n              c=resu[[1]]\n              w=resu[[3]]\n              m=t(w)%*%c\n              m=as.numeric(m)\n              return(m)\n            }  else\n              stop('Something wrong, null domain or cdf')\n          }\n)\n#' @rdname stdH-methods\n#' @aliases stdH,distributionH-method \n#' @description Standard deviation of a histogram (i.e., the square root of the centered\n#' second moment)\n#'  \n#' @param object a \\code{distributionH} object\n#' @return A value for the standard deviation\n#' @author Antonio Irpino\n#' @keywords distribution\n#' @examples\n#' \n#' ##---- A mydist distribution ----\n#' mydist<-distributionH(x=c(1,2,3,10), p=c(0,0.1,0.5,1))\n#' ##---- Compute the standard deviation of mydist ----\n#' stdH(mydist) #---> 2.563851\n#'\nsetMethod(\"stdH\",\"distributionH\",\n          function(object){\n            if (!is.null(object@x)||!is.null(object@p)){\n              resu=crwtransform(object)\n              c=resu[[1]]\n              r=resu[[2]]\n              w=resu[[3]]\n              std=sqrt(t(w)%*%(c^2+1/3*r^2)-(t(w)%*%c)^2);\n              std=as.numeric(std)\n              return(std)\n            }  else\n              stop('Something wrong, null domain or cdf')\n          }\n)\n#' @rdname skewH-methods\n#' @aliases skewH,distributionH-method \n#' @description Skewness of a histogram (using the third standardized moment)\n#'  \n#' @param object a \\code{distributionH} object\n#' @return A value for the skewness index\n#' @author Antonio Irpino\n#' @keywords distribution\n#' @examples\n#' \n#' ##---- A mydist distribution ----\n#' mydist<-distributionH(x=c(1,2,3,10), p=c(0,0.1,0.5,1))\n#' ##---- Compute the skewness of mydist ----\n#' skewH(mydist) #---> -1.186017\n#'\nsetMethod(\"skewH\",\"distributionH\",\n          function(object){\n            if (!is.null(object@x)||!is.null(object@p)){\n              resu=crwtransform(object)\n              cs=(resu[[1]]-object@m)/(object@s)\n              rs=resu[[2]]/(object@s)\n              w=resu[[3]]\n              sk=t(w)%*%(cs*(rs^2+cs^2));\n              sk=as.numeric(sk)\n              return(sk)\n            }  else\n              stop('Something wrong, null domain or cdf')\n          }\n)\n#' @rdname kurtH-methods\n#' @aliases kurtH,distributionH-method \n#' @description Kurtosis of a histogram (using the fourth standardized moment)\n#' @param object a \\code{distributionH} object\n#' @return A value for the kurtosis index, 3 is the kurtosis of a Gaussian\n#' distribution\n#' @author Antonio Irpino\n#' @keywords distribution\n#' @examples\n#' \n#' ##---- A mydist distribution ----\n#' mydist<-distributionH(x=c(1,2,3,10), p=c(0,0.1,0.5,1))\n#' ##---- Compute the kurtosis of mydist ----\n#' kurtH(mydist) #---> 1.473242\n#' \n\nsetMethod(\"kurtH\",\"distributionH\",\n          function(object){\n            if (!is.null(object@x)||!is.null(object@p)){\n              resu=crwtransform(object)\n              cs=(resu[[1]]-object@m)/(object@s)\n              rs=resu[[2]]/(object@s)\n              w=resu[[3]]\n              ku=0.2*t(w)%*%(5*cs^4+10*(cs^2)*rs^2+rs^4)\n              ku=as.numeric(ku)\n              return(ku)\n            }  else\n              stop('Something wrong, null domain or cdf')\n          }\n)\n#' @rdname crwtransform-methods\n#' @aliases crwtransform,distributionH-method \n#' \n#' @description Centers and ranges calculation for bins of a histogram. It is useful for a\n#' very fast computation of statistics and methods based on the L2 Wassertein\n#' distance between histograms. \n#' @param object a \\code{distributionH} object\n#' @return A list containing \\item{$Centers }{The midpoints of the bins of the\n#' histogram} \\item{$Radii }{The half-lenghts of the bins of the histogram}\n#' \\item{$Weights }{The relative frequencies or the probailities associated with\n#' each bin (the sum is equal to 1)}\n#' @author Antonio Irpino\n#' @references Irpino, A., Verde, R., Lechevallier, Y. (2006) \\emph{Dynamic\n#' clustering of histograms using Wasserstein metric}, In: Proceedings of\n#' COMPSTAT 2006, Physica-Verlag, 869-876\n#' @keywords distribution\n#' @examples\n#' \n#' ##---- A mydist distribution ----\n#' mydist<-distributionH(x=c(1,2,3,10), p=c(0,0.1,0.5,1))\n#' ##---- Compute the cfd value for q=5 (not observed) ----\n#' crwtransform(mydist)\n\nsetMethod(\"crwtransform\",\"distributionH\",\n          function(object){\n            if (!is.null(object@x)||!is.null(object@p)){\n              resu=list()\n              nv=length(object@x)\n              c=(object@x[2:nv]+object@x[1:(nv-1)])/2\n              r=(object@x[2:nv]-object@x[1:(nv-1)])/2\n              w=object@p[2:nv]-object@p[1:(nv-1)]\n              resu=list(Centers=c,Radii=r,Weights=w)\n              return(resu)\n            }  else\n              stop('Something wrong, null domain or cdf')\n          }\n)\n# Overloading of the sum of two distribution according to the L2 w --------\n#' Method +\n#' @name +\n#' @aliases +,distributionH,distributionH-method\n#' @description the sum of two distribution according to the L2 Wasssertein\n#' @param e1 a \\code{distributionH} object or a number\n#' @param e2 a \\code{distributionH} object or a number\n#' @return a \\code{distributionH} object\n#' @export\n#' @docType methods\n#' @rdname plus-methods\n#' \nsetMethod(\"+\",\n          signature(e1 = \"distributionH\",e2=\"distributionH\"),\n          function (e1, e2) \n          {\n            tmp=register(e1,e2)\n            x=callGeneric(tmp[[1]]@x,tmp[[2]]@x)\n            OBJ_NEW=new(\"distributionH\",x,tmp[[1]]@p,(tmp[[1]]@m+tmp[[2]]@m))\n          }\n)\n#' Method +\n#' @name +\n#' @aliases +,numeric,distributionH-method\n#' @description the sum of a number and a distribution according to the L2 Wasssertein\n#' @export\n#' @docType methods\n#' @rdname plus-methods\n\nsetMethod(\"+\",\n          signature(e1 = \"numeric\",e2=\"distributionH\"),\n          function (e1, e2) \n          {\n            x=callGeneric(rep(e1,length(e2@x)),e2@x)\n            OBJ_NEW=new(\"distributionH\",x,e2@p,(e1+e2@m),e2@s)\n          }\n)\n#' Method +\n#' @name +\n#' @aliases +,distributionH,numeric-method\n#' @description the sum of adistribution and a number according to the L2 Wasssertein\n#' @export\n#' @docType methods\n#' @rdname plus-methods\nsetMethod(\"+\",\n          signature(e1 = \"distributionH\", e2=\"numeric\"),\n          function (e1, e2) \n          {\n            x=callGeneric(rep(e2,length(e1@x)),e1@x)\n            OBJ_NEW=new(\"distributionH\",x,e1@p,(e2+e1@m),e1@s)\n          }\n)\n# Overloading of the difference of two distributions according to the L2 wasserstein --------\n#' Method -\n#' @name minus\n#' @aliases -,distributionH,distributionH-method \n#' @description the difference of two distribution according to the L2 Wasssertein\nsetMethod(\"-\",\n          signature(e1 = \"distributionH\",e2=\"distributionH\"),\n          function (e1, e2) \n          {\n            tmp=register(e1,e2)\n            x=callGeneric(tmp[[1]]@x,tmp[[2]]@x)\n            OBJ_NEW=new(\"distributionH\",x,tmp[[1]]@p)\n          }\n)\n#' Method -\n#' @name minus\n#' @aliases -,numeric,distributionH-method \n#' @param e1 a \\code{distributionH} object or a number\n#' @param e2 a \\code{distributionH} object or a number\n#' @description the difference of a number and a distribution according to the L2 Wasssertein\nsetMethod(\"-\",\n          signature(e1 = \"numeric\",e2=\"distributionH\"),\n          function (e1, e2) \n          {\n            x=callGeneric(rep(e1,length(e2@x)),e2@x)\n            OBJ_NEW=new(\"distributionH\",x,e2@p)\n          }\n)\n#' Method -\n#' @name minus\n#' @aliases -,distributionH,numeric-method \n#' @description the difference of a distribution and a number according to the L2 Wasssertein\n#' @note it may not works properly if the difference is not a distribution\nsetMethod(\"-\",\n          signature(e1 = \"distributionH\", e2=\"numeric\"),\n          function (e1, e2) \n          {\n            x=callGeneric(e1@x,rep(e2,length(e1@x)))\n            OBJ_NEW=new(\"distributionH\",x,e1@p,(e1@m-e2),e1@s)\n          }\n)\n\n# Overloading of the product of a number by a distribution according to the L2 w --------\n#' Method *\n#' @name *-methods\n#' @aliases *,distributionH,distributionH-method\n#' @description the product of a number and a distribution according to the L2 Wasssertein\n#' @param e1 a \\code{distributionH} object or a number\n#' @param e2 a \\code{distributionH} object or a number\nsetMethod(\"*\",\n          signature(e1 = \"distributionH\",e2=\"distributionH\"),\n          function (e1, e2) \n          {\n            stop('please use dotpW function product between distributions')\n          }\n)\n#' Method *\n#' @name *-methods\n#' @aliases *,numeric,distributionH-method\n#' @description the product of a number and a distribution according to the L2 Wasssertein\nsetMethod(\"*\",\n          signature(e1 = \"numeric\",e2=\"distributionH\"),\n          function (e1, e2) \n          {\n            x=callGeneric(rep(e1,length(e2@x)),e2@x)\n            OBJ_NEW=new(\"distributionH\",x,e2@p,e1*e2@m,e1*e2@s)\n          }\n)\n#' Method *\n#' @name *-methods\n#' @aliases *,distributionH,numeric-method\n#' @description the product of a number and a distribution according to the L2 Wasssertein\nsetMethod(\"*\",\n          signature(e1 = \"distributionH\", e2=\"numeric\"),\n          function (e1, e2) \n          {\n            x=callGeneric(rep(e2,length(e1@x)),e1@x)\n            OBJ_NEW=new(\"distributionH\",x,e1@p,e2*e1@m,e2*e1@s)\n          }\n)\n\n# Utilities for single or couples of distributionH --------------------------------\n#' Method \\code{checkEmptyBins}\n#' @name checkEmptyBins\n#' @rdname checkEmptyBins-methods\n#' @exportMethod checkEmptyBins\nsetGeneric(\"checkEmptyBins\", function(object) standardGeneric(\"checkEmptyBins\"))\n#' Method \\code{compQ}\n#' @name compQ\n#' @rdname compQ-methods\n#' @exportMethod compQ\nsetGeneric(\"compQ\", function(object,p) standardGeneric(\"compQ\"))\n#' Method \\code{compP}\n#' @name compP\n#' @rdname compP-methods\n#' @exportMethod compP\nsetGeneric(\"compP\", function(object,q) standardGeneric(\"compP\"))\n#' Method \\code{register}\n#' @name register\n#' @rdname register-methods\n#' @exportMethod register\nsetGeneric(\"register\", function(object1,object2) standardGeneric(\"register\"))\n\n#' @rdname register-methods\n#' @aliases register,distributionH-method \n#' @description Given two \\code{distributionH} objects, it returns two equivalent distributions such that \n#' they share the same cdf values. This function is useful for computing basic statistics.\n#' \n#' @param object1 A \\code{distributionH} object\n#' @param object2 A \\code{distributionH} object\n#' @return The two \\code{distributionH} objects in input sharing the same cdf (the \\code{p}\n#' slot)\n#' @author Antonio Irpino\n#' @references Irpino, A., Lechevallier, Y. and Verde, R. (2006): \\emph{Dynamic\n#' clustering of histograms using Wasserstein metric} In: Rizzi, A., Vichi, M.\n#' (eds.) COMPSTAT 2006. Physica-Verlag, Berlin, 869-876.\\cr Irpino, A.,Verde,\n#' R. (2006): \\emph{A new Wasserstein based distance for the hierarchical\n#' clustering of histogram symbolic data} In: Batanjeli, V., Bock, H.H.,\n#' Ferligoj, A., Ziberna, A. (eds.) Data Science and Classification, IFCS 2006.\n#' Springer, Berlin, 185-192.\n#' @keywords distribution\n#' @examples\n#' \n#' ##---- initialize two distributionH objects mydist1 and mydist2\n#'  mydist1=distributionH(c(1,2,3),c(0, 0.4, 1))\n#'  mydist2=distributionH(c(7,8,10,15),c(0, 0.2, 0.7, 1))\n#'  ## register the two distributions\n#'  regDist=register(mydist1,mydist2)\n#'  \n#' ## OUTPUT:\n#' ## regDist$[[1]]\n#' ## An object of class \"distributionH\"\n#' ## Slot \"x\": [1] 1.0 1.5 2.0 2.5 3.0\n#' ## Slot \"p\": [1] 0.0 0.2 0.4 0.7 1.0\n#' ## ...\n#' ## regDist$[[2]] \n#' ## An object of class \"distributionH\"\n#' ## Slot \"x\": [1] 7.0 8.0 8.8 10.0 15.0\n#' ## Slot \"p\": [1] 0.0 0.2 0.4  0.7  1.0\n#' ## ...\n#' \nsetMethod(f=\"register\",signature=c(object1=\"distributionH\",object2=\"distributionH\"),\n          function(object1,object2){\n            if (!identical(object1@p,object2@p)){\n              commoncdf=sort(unique(c(object1@p,object2@p)))\n              nr=length(commoncdf)\n              result=matrix(0,nr,3)\n              result[,3]=commoncdf\n              result[1,1:2]=c(object1@x[1],object2@x[1])\n              result[nr,1:2]=c(object1@x[length(object1@x)],object2@x[length(object2@x)])\n              if (nr>2) {\n                for (i in c(2:(nr-1))){\n                  result[i,1] =compQ(object1,result[i,3])\n                  result[i,2] =compQ(object2,result[i,3])\n                }\n              } \n              o1=new(\"distributionH\",as.vector(result[,1]),as.vector(commoncdf))\n              o2=new(\"distributionH\",as.vector(result[,2]),as.vector(commoncdf))\n              return(c(o1,o2))\n            }\n            else{\n              return(c(object1,object2))\n            }\n            \n          }\n)\n#' @rdname checkEmptyBins-methods\n#' @aliases checkEmptyBins,distributionH-method \n#' @description The method checking for empty bins in a distribution, i.e. if two cdf consecutive\n#' values are equal. In that case a probability value of \\code{1e-7} is\n#' assigned to the empty bin and the cdf is recomputed. This methods is useful\n#' for numerical reasons.\n#' \n#' \n#' @param object a \\code{distributionH} object\n#' @return A \\code{distributionH} object without empty bins\n#' @author Antonio Irpino\n#' @keywords distribution\n#' @examples\n#' \n#' ##---- A mydist distribution with an empty bin i.e. two consecutive values of p are equal----\n#' mydist<-distributionH(x=c(1,2,3,10), p=c(0,0.5,0.5,1))\n#' ##---- Checks for empty byns and returns the newdist object without empty bins ----\n#' newdist<-checkEmptyBins(mydist)\n#'\nsetMethod(f=\"checkEmptyBins\",signature=\"distributionH\",\n            function(object){\n            w=object@p[2:length(object@p)]-object@p[1:(length(object@p)-1)]\n            TOL=1e-08\n            if (length(which(w<=TOL))){\n              w[which(w<TOL)]=10*TOL\n              object@p=c(0,cumsum(w))/sum(w)\n              \n            }\n            return(object)\n          }\n)\n#' @rdname compQ-methods\n#' @aliases compQ,distributionH-method \n#' @description Compute the quantile value of a histogram for a given probability. \n#' \n#' \n#' @param object an object of \\env{distributionH} class\n#' @param p a number between 0 and 1\n#' @return \\deqn{y= F^{-1}(p)=Q(p)} A number that is the quantile of the passed\n#' histogram \\env{object} at level \\env{p}.\n#' @author Antonio Irpino\n#' @keywords ~kwd1 ~kwd2\n#' @examples\n#' \n#' ##---- A mydist distribution ----\n#' mydist<-distributionH(x=c(1,2,3,10), p=c(0,0.1,0.5,1))\n#' ##---- Compute the quantile of mydist for different values of p ----\n#' y<-compQ(mydist,0.5) #the median\n#' y<-compQ(mydist,0) #the minimum\n#' y<-compQ(mydist,1) #the maximum\n#' y<-compQ(mydist,0.25) #the first quartile\n#' y<-compQ(mydist,0.9) #the ninth decile\n#' \nsetMethod(f=\"compQ\",signature=c(object=\"distributionH\",p=\"numeric\"),\n          function(object,p){\n            # %Computes the p-th quantile p=[0,1] of the distribution o1\n            # %INPUT  - p  a value in [0,1]\n            # %           - o1 a distribution\n            # %OUTPUT-  res the computed quantile\n            # %example:q=compQ(o1,0.5) returns the median of the\n            # % distribution o1\n            \n            #Check for errors\n            if (p<0 || p>1) stop(\"p must be a value between 0 and 1\")\n            \n            if (p<=0) return(q=object@x[1])\n            if (p>=1) return (q=object@x[length(object@x)])\n            \n            ini=max(object@x[object@p<=p])\n            pos1=which.max(object@x[object@p<=p])\n            pos2=pos1+1\n            fin=object@x[pos2];\n            if (ini==fin){\n              q=ini\n            }\n            else{\n              q=ini+(object@x[pos2]-object@x[pos1])*(p-object@p[pos1])/(object@p[pos2]-object@p[pos1])\n            }\n            return(q)\n          }\n)\n#' @rdname compP-methods\n#' @aliases compP,distributionH-method \n#' @description Compute the cdf probability at a given value for a histogram\n#' \n#' @param object is an object of \\env{distributionH} class\n#' @param q is a numeric value\n#' @return Returns a value between 0 and 1.\n#' @keywords distribution\n#' @examples\n#' \n#' ##---- A mydist distribution ----\n#' mydist<-distributionH(x=c(1,2,3,10), p=c(0,0.1,0.5,1))\n#' ##---- Compute the cfd value for q=5 (not observed) ----\n#' p<-compP(mydist,5)\n#'\nsetMethod(f=\"compP\",signature=c(object=\"distributionH\",q=\"numeric\"),\n          function(object,q){\n            domain=object@x\n            cumul=object@p\n            if (q<=domain[1]) return(p=0)\n            if (q>=domain[length(domain)]) return(p=1)\n            \n            ini=max(cumul[domain<=q])\n            pos1=which.max(cumul[domain<=q])\n            pos2=pos1+1\n            fin=cumul[pos2]\n            \n            if (ini==fin){\n              p=fin}\n            else{\n              p=ini+(cumul[pos2]-cumul[pos1])*(q-domain[pos1])/(domain[pos2]-domain[pos1])}\n            return(as.numeric(p))\n          }\n)\n# L2 Wasserstein distance between two distributions and related results ----\n#' Method \\code{WassSqDistH}\n#' @name WassSqDistH\n#' @rdname WassSqDistH-methods\n#' @exportMethod WassSqDistH\nsetGeneric(\"WassSqDistH\", function(object1,object2,...) standardGeneric(\"WassSqDistH\"))# Wasserstein distance between two distributions\n#' Method \\code{rQQ}\n#' @name rQQ\n#' @rdname rQQ-methods\n#' @exportMethod rQQ\nsetGeneric(\"rQQ\", function(e1,e2) standardGeneric(\"rQQ\"))# Quantile-Quantile correlation between twi distributions\n\n#' @rdname WassSqDistH-methods\n#' @aliases WassSqDistH,distributionH-method \n#' @description Computes the squared L2 Wasserstein distance between two \\code{distributionH} objects.\n#' @param object1 is an object of \\env{distributionH} class\n#' @param object2 is an object of \\env{distributionH} class\n#' @param ... optional parameters\n#' @param details (optional, default=FALSE) is a logical value, if TRUE returns the decomposition of the distance\n#' @return \n#' If \\code{details=FALSE}, the function returns the squared L2 Wasserstein distance.\\cr\n#' If \\code{details=TRUE}, the function returns list containing the squared distance, its \n#' decomposition in three parts (position, size and shape) and the correlation coefficient between the quantile functions.\n#' @references\n#' Irpino, A. and Romano, E. (2007): \\emph{Optimal histogram representation of large data sets: \n#' Fisher vs piecewise linear approximations}. RNTI E-9, 99-110.\\cr\n#' Irpino, A., Verde, R. (2015) \\emph{Basic\n#' statistics for distributional symbolic variables: a new metric-based\n#' approach} Advances in Data Analysis and Classification, DOI 10.1007/s11634-014-0176-4\n#' @keywords distribution\n#' @examples\n#' ##---- create two distributionH objects ----\n#'  mydist1=distributionH(x=c(1,2,3),p=c(0, 0.4, 1))\n#'  mydist2=distributionH(x=c(7,8,10,15),p=c(0, 0.2, 0.7, 1))\n#'# -- compute the squared L2 Waaserstein distance\n#' WassSqDistH(mydist1,mydist2)\n#'# -- compute the squared L2 Waaserstein distance with details\n#' WassSqDistH(mydist1,mydist2,details=TRUE)\nsetMethod(f=\"WassSqDistH\",signature=c(object1=\"distributionH\",object2=\"distributionH\"),\n          #Computes the L2 Wasserstein squared distance between two distributions\n          #INPUT: object1 and object2 - two distributionH objects\n          #OUTPUT: A list containing the distance and its decomposition in three parts (position, size and shape)\n          function(object1=object1,object2=object2,details=FALSE){\n            tmp=register(object1,object2)\n            nv=length(tmp[[1]]@p)\n            w=tmp[[1]]@p[2:nv]-tmp[[1]]@p[1:(nv-1)]\n            c1=0.5*(tmp[[1]]@x[2:nv]+tmp[[1]]@x[1:(nv-1)])\n            c2=0.5*(tmp[[2]]@x[2:nv]+tmp[[2]]@x[1:(nv-1)])\n            r1=0.5*(tmp[[1]]@x[2:nv]-tmp[[1]]@x[1:(nv-1)])\n            r2=0.5*(tmp[[2]]@x[2:nv]-tmp[[2]]@x[1:(nv-1)])\n            D=t(w)%*%((c1-c2)^2+1/3*(r1-r2)^2)\n            if (details) {\n              DC=(object1@m-object2@m)^2\n              DS=(object1@s-object2@s)^2\n              if(abs(D-DC-DS)<1e-10) DR=0 else DR=abs(D-DC-DS)\n              \n              rho=1-abs(D-DC-DS)/(2*object1@s*object2@s)\n              if (rho<0) rho=0\n              resu=c(D,DC,DS,DR,rho)\n              names(resu)=c(\"SQ_W_dist\", \"POSITION\", \"SIZE\", \"SHAPE\", \"rQQ\")\n              return(resu)}\n            else return(as.numeric(D))\n          }\n)\n\n#' Method \\code{dotpW}\n#' @name dotpW\n#' @rdname dotpW-methods\n#' @exportMethod dotpW\nsetGeneric(\"dotpW\", function(e1,e2) standardGeneric(\"dotpW\"))#dotproduct from L2 Wasserstein\n#' @rdname dotpW-methods\n#' @aliases dotpW,distributionH-method \n#' @description The dot product of two distributions inducing the L2 Wasserstein metric\n#' \n#' @param e1 a \\code{distributionH} object or a number\n#' @param e2 a \\code{distributionH} object or a number\n#' @return A numeric value\n#' @author Antonio Irpino\n#' @references  Irpino, A., Verde, R. (2015) \\emph{Basic\n#' statistics for distributional symbolic variables: a new metric-based\n#' approach} Advances in Data Analysis and Classification, DOI 10.1007/s11634-014-0176-4\n#' @keywords distribution\n#' @examples\n#' \n#' ## let's define two distributionH objects\n#' mydist1<-distributionH(x=c(1,2,3,10), p=c(0,0.1,0.5,1))\n#' mydist2<-distributionH(x=c(5,7,15), p=c(0,0.7,1))\n#' \n#' ## the dot product between the distributions\n#' dotpW(mydist1,mydist2) #---> 39.51429\n#' \n#' ## the dot product between a distribution and a numeric\n#' dotpW(mydist1,3)  #---> 13.2\n#' dotpW(3,mydist1)  #---> 13.2\n#' \n#' \n\nsetMethod(\"dotpW\",\n          signature(e1 = \"distributionH\",e2=\"distributionH\"),\n          definition = function (e1, e2) \n          {\n            tmp=register(e1,e2)\n            w=tmp[[1]]@p[2:length(tmp[[1]]@p)]-tmp[[1]]@p[1:(length(tmp[[1]]@p)-1)]\n            c1=(tmp[[1]]@x[2:length(tmp[[1]]@p)]+tmp[[1]]@x[1:(length(tmp[[1]]@p)-1)])/2\n            c2=(tmp[[2]]@x[2:length(tmp[[1]]@p)]+tmp[[2]]@x[1:(length(tmp[[1]]@p)-1)])/2\n            r1=(tmp[[1]]@x[2:length(tmp[[1]]@p)]-tmp[[1]]@x[1:(length(tmp[[1]]@p)-1)])/2\n            r2=(tmp[[2]]@x[2:length(tmp[[1]]@p)]-tmp[[2]]@x[1:(length(tmp[[1]]@p)-1)])/2              \n            dprod=sum(w*(c1*c2+1/3*r1*r2))\n            return(dprod)\n          }\n)\n#' @rdname dotpW-methods\n#' @aliases dotpW,distributionH-method \n#' @description The dot product of a number (considered as an impulse distribution function) and a distribution\nsetMethod(\"dotpW\",\n          signature(e1 = \"numeric\",e2=\"distributionH\"),\n          function (e1, e2) \n          {\n            dprod=e1*e2@m\n            return(dprod)\n          }\n)\n#' @rdname dotpW-methods\n#' @aliases dotpW,distributionH-method \n#' @description The dot product of a distribution and a number (considered as an impulse distribution function).\nsetMethod(\"dotpW\",\n          signature(e1 = \"distributionH\", e2=\"numeric\"),\n          function (e1, e2) \n          {\n            dprod=e2*e1@m\n            return(dprod)\n          }\n)\n#' @rdname rQQ-methods\n#' @aliases rQQ,distributionH-method \n#' @description Quantile-Quantile correlation between two distributions\n#' @param e1  A \\code{distributionH} object\n#' @param e2  A \\code{distributionH} object\n#' @return Pearson correlation index between quantiles\n#' @author Antonio Irpino\n#' @references  Irpino, A., Verde, R. (2015) \\emph{Basic\n#' statistics for distributional symbolic variables: a new metric-based\n#' approach} Advances in Data Analysis and Classification, DOI 10.1007/s11634-014-0176-4\n#' @examples\n#' \n#' ##---- initialize two distributionH object mydist1 and mydist2\n#'  mydist1<-distributionH(x=c(1,2,3),p=c(0, 0.4, 1))\n#'  mydist2<-distributionH(x=c(7,8,10,15),p=c(0, 0.2, 0.7, 1))\n#'  ## computes the rQQ\n#'  rQQ(mydist1,mydist2)\n#'  ## OUTPUT 0.916894\n#' \n#' @export rQQ\nsetMethod(\"rQQ\",\n          signature(e1 = \"distributionH\",e2=\"distributionH\"),\n          definition = function (e1, e2) \n          {\n            rQQ=(dotpW(e1,e2)-e1@m*e2@m)/(e1@s*e2@s)\n            return(rQQ)\n          }\n)\n## ---- Show overridding for distributionH and MatH ----\n#' Method show for distributionH\n#' @name show\n#' @rdname show-distributionH-methods\n#' @docType methods\n#' @aliases show,distributionH-method \n#' @description An overriding show function for a \\code{distributionH} object. The function returns a representation \n#' of the histogram, if the number of bins is high the central part of the histogram is truncated. \n#' @param object a \\code{distributionH} object\n#' @examples\n#' ##---- initialize a distributionH\n#'  mydist<-distributionH(x=c(7,8,10,15),p=c(0, 0.2, 0.7, 1))\n#'  # show the histogram\n#'  mydist\nsetMethod(\"show\",\n          signature(object=\"distributionH\"),\n          definition=function(object){\n            if(length(object@p)>2){\n            mymat=matrix(0,length(object@p)-1,2)\n            if (length(object@p)>11){\n              cat(\"Output shows the first five and the last five bins due to eccesive length \\n\")\n              mymat=matrix(0,12,2)\n              mymat[1,1]=\"X\"\n              mymat[1,2]=\"p\"\n              count=0\n              for (i in 2:6){\n                count=count+1\n                mymat[count+1,1]=paste(\"[\",format(object@x[(i-1)],digits=5),\"-\",format(object@x[i],digits=5),\")\",sep=\"\") \n                mymat[count+1,2]=paste(format(object@p[i]-object@p[i-1],digits=4))\n              }\n              count=count+1\n              mymat[count+1,1]=paste(\"...\") \n              mymat[count+1,2]=paste(\"...\")\n              for (i in (length(object@p)-4):length(object@p)){\n                count=count+1\n                mymat[count+1,1]=paste(\"[\",format(object@x[(i-1)],digits=5),\" ; \",format(object@x[i],digits=5),\")\",sep=\"\")  \n                mymat[count+1,2]=paste(format(object@p[i]-object@p[i-1],digits=4))\n              }\n              rownames(mymat)=c(\"\", paste(\"Bin\",1:5,sep=\"_\"),\"...\",\n                                paste(\"Bin\",(length(object@p)-5):(length(object@p)-1),sep=\"_\"))\n              write.table(format(mymat, justify=\"right\",digits=5),\n                          row.names=T, col.names=F, quote=F)  \n            }\n            else{\n              mymat=matrix(0,length(object@p),2)\n              mymat[1,1]=\"X\"\n              mymat[1,2]=\"p\"\n              for (i in 2:(length(object@p)-1)){\n                mymat[i,1]=paste(\"[ \",format(object@x[(i-1)],digits=5),\" ; \",format(object@x[i],digits=5),\" )\",sep=\"\")  \n                mymat[i,2]=paste(format(object@p[i]-object@p[i-1],digits=4))\n              }\n              mymat[length(object@p),1]=paste(\"[ \",format(object@x[(length(object@p)-1)],digits=5),\n                                              \" ; \",format(object@x[length(object@p)],digits=5),\" ]\",sep=\"\")  \n              mymat[length(object@p),2]=paste(format(object@p[length(object@p)]-object@p[length(object@p)-1],digits=4))\n              \n              rownames(mymat)=c(\" \", paste(\"Bin\",1:(length(object@p)-1),sep=\"_\"))\n              write.table(format(mymat, justify=\"right\"),\n                          row.names=T, col.names=F, quote=F)\n            }\n            cat(paste(\"\\n mean = \",object@m, \"  std  = \",object@s,\"\\n \"))\n            \n            } else (cat(\"Empty distributionH\\n\"))\n          }\n)\n\n\n\n\n## --- Plot  for distributionH  ----\n#' plot for a distributionH object\n#' @name plot-distributionH\n#' @docType methods\n#' @aliases plot,distributionH-method\n#' @description A plot function for a \\code{distributionH} object. The function returns a representation \n#' of the histogram.\n#' @param x  a \\code{distributionH} object\n#' @param ... other optional parameters\n#' @param type (optional) a string describing the type of plot, default=\"HISTO\".\\cr Other allowed types are \n#' \\cr\"CDF\"=Cumulative distribution function, \\cr\"QF\"= quantile function, \\cr\"DENS\"=a density approximation, \n#' \\cr\"HBOXPLOT\"=horizontal boxplot, \\cr\"VBOXPLOT\"= vertical boxplot,\n#'  @param col (optional) a string the color of the plot, default=\"green\".\n#'  @param border (optional) a string the color of the border of the plot, default=\"black\".\n#' @examples\n#' ##---- initialize a distributionH\n#'  mydist<-distributionH(x=c(7,8,10,15),p=c(0, 0.2, 0.7, 1))\n#'  # show the histogram\n#'  plot(mydist) #plots mydist\n#'  plot(mydist, type=\"HISTO\", col=\"red\", border=\"blue\") #plots mydist\n#'  plot(mydist, type=\"DENS\", col=\"red\", border=\"blue\") #plots a density approximation for mydist\n#'  plot(mydist, type=\"HBOXPLOT\") #plots a horizontal boxplot for mydist\n#'  plot(mydist, type=\"VBOXPLOT\") #plots a vertical boxplot for mydist\n#'  plot(mydist, type=\"CDF\") #plots the cumulative distribution function of mydist\n#'  plot(mydist, type=\"QF\") #plots the quantile function of mydist\n#' @export\nsetMethod(\"plot\",\n          signature(x = \"distributionH\" ),\n          function (x,  type=\"HISTO\",col=\"green\",border=\"black\") \n          {\n            xlabel=paste(\"m= \",x@m,\" std= \",x@s)\n            if (type==\"HISTO\"){\n              lowers=x@x[1:(length(x@x)-1)]\n              uppers=x@x[2:length(x@x)]\n              ampl=uppers-lowers\n              #ampl[which(ampl==0)]=1\n              dens=(x@p[2:length(x@p)]-x@p[1:(length(x@p)-1)])/ampl\n              plot(c(lowers[1],uppers[length(uppers)]), c(0,max(dens[dens<Inf]))*1.1, type= \"n\", xlab = xlabel, ylab = \"density\")\n              for (i in 1:length(lowers)){\n                if (ampl[i]==0){\n                  segments(lowers[i],0,lowers[i],1,lwd=2)\n                }\n                else{\n                  rect(lowers[i], 0, uppers[i], dens[i], col = col, border = border)\n                }\n              }\n              title(\"Histogram\")\n              \n            }\n            if (type==\"CDF\"){\n              xs=x@x\n              ps=x@p\n              plot(c(min(xs),max(xs)), c(0,1), type= \"n\", xlab = \"\", ylab = \"\")\n              plot(xs,ps,type=\"l\",col=border,xlab=xlabel, ylab=\"Prob\")\n              title(\"Cumulative distribution function\")\n              \n            }\n            if (type==\"QF\"){\n              xs=x@p\n              ps=x@x\n              plot(c(min(xs),max(xs)), c(0,1), type= \"n\", xlab = \"\", ylab = \"\")\n              plot(xs,ps,type=\"l\",col=border,xlab=xlabel, ylab=\"domain\")\n              title(\"Quantile function\")\n              \n            }\n            if (type==\"DENS\"){\n              #generate 200 random points according to the QF\n              rn=200\n              \n              \n              xn=c(rep(0,rn))\n              random_no=c(0:rn)/rn\n              \n              for (i in 1:rn){\n                xn[i]=compQ(x,random_no[i])\n              }\n              d <- density(xn)\n              plot(c(d$x[1],d$x[length(d$x)]), c(0,max(d$y)), type= \"n\",  xlab = xlabel, ylab = \"density\")\n              polygon(d$x,d$y, col=col, border=border)\n              title(\"Density plot (kde)\")\n            }\n            if (type==\"HBOXPLOT\"){\n              qua=c(0,0.25,0.5,0.75,1)\n              xn=c(0,0,0,0,0)\n              for (i in 1:5){\n                xn[i]=compQ(x,qua[i])\n              }\n              plot(c(xn[1],xn[5]), c(0.7,2.3), type= \"n\", xlab = xlabel, yaxt=\"n\",ylab=\"\")\n              \n              rect(xn[2], 1, xn[3], 2, col = col, border = border)\n              rect(xn[3], 1, xn[4], 2, col = col, border = border)\n              segments(xn[1], 1.5, xn[2], 1.5,col=\"black\")\n              segments(xn[4], 1.5, xn[5], 1.5,col=\"black\")\n              segments(xn[1], 1, xn[1], 2,col=\"black\")\n              segments(xn[5], 1, xn[5], 2,col=\"black\")\n              title(\"Horizontal Box-plot\")\n            }\n            if (type==\"VBOXPLOT\"){\n              qua=c(0,0.25,0.5,0.75,1)\n              xn=c(0,0,0,0,0)\n              for (i in 1:5){\n                xn[i]=compQ(x,qua[i])\n              }\n              plot( c(0.7,2.3), c(xn[1],xn[5]),, type= \"n\", xaxt=\"n\", xlab = xlabel,ylab=\"\")\n              \n              rect(1, xn[2], 2, xn[3], col = col, border = border)\n              rect(1, xn[3], 2, xn[4],  col = col, border = border)\n              segments(1.5, xn[1], 1.5, xn[2],col=\"black\")\n              segments(1.5, xn[4], 1.5, xn[5],col=\"black\")\n              segments(1, xn[1], 2, xn[1],col=\"black\")\n              segments(1, xn[5], 2, xn[5],col=\"black\")\n              title(\"Vertical Box-plot\")\n            }\n          }\n)",
    "created" : 1424119838318.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "807|38|853|10|\n888|11|972|10|\n",
    "hash" : "4201334414",
    "id" : "B11E4220",
    "lastKnownWriteTime" : 1424174866,
    "path" : "C:/Users/Antonio/Desktop/HISTO_R_PACK/HistDAWass/R/Met_distributionH.R",
    "project_path" : "R/Met_distributionH.R",
    "properties" : {
    },
    "source_on_save" : true,
    "type" : "r_source"
}